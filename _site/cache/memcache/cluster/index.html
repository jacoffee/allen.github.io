<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>基于Memcached Java客户端Xmemcached的一致性哈希研究</title>
    <meta name="description" content="本文研究了Memcache集群相关的问题" />
    <meta name="keywords" content="一致性哈希，取余，Memcache集群，"客户端分布式"，Xmemcached" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    基于Memcached Java客户端Xmemcached的一致性哈希研究
</p>

<h1 class="lotus-pagetit">基于Memcached Java客户端Xmemcached的一致性哈希研究</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2016-03-27">2016-03-27</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>谈起Memcache中的一致性哈希，首先要明确的一点是Memcache集群与一般的服务器端集群还不太一样，最显著的一点就是Memcache的各台服务器之间并没有通讯机制，也就是如果一台服务器挂了，其它的服务根本就不知道(关于Memcached如何防止单点故障会在另一篇文章中提到)。</p>

<p>Memcache实际上没有集群的概念，它的分布式主要是靠客户端实现的，客户端决定采用什么算法将Key如何均匀的分布到服务器上并且在服务器增加或减小的时候，减小Rehash(重算哈希)。这里借助Memcache的Java客户端<a href="https://code.google.com/p/xmemcached/wiki/User_Guide">Xmemcached</a>来介绍两种实现。</p>

<h3><1> Xmemcached对于连接的抽象</h3>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">addrs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"127.0.0.1:11211"</span><span class="o">,</span> <span class="s">"127.0.0.1:11311"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">builder</span> <span class="k">=</span> <span class="o">{</span>
<span class="k">val</span> <span class="n">clientBuilder</span> <span class="k">=</span> 
   <span class="k">new</span> <span class="nc">XMemcachedClientBuilder</span><span class="o">(</span><span class="nc">AddrUtil</span><span class="o">.</span><span class="n">getAddresses</span><span class="o">(</span><span class="n">addrs</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">" "</span><span class="o">)))</span>
  <span class="c1">// 默认的SessionLocator是ArrayMemcachedSessionLocator
</span>  <span class="n">clientBuilder</span><span class="o">.</span><span class="n">setSessionLocator</span><span class="o">(</span><span class="k">new</span> <span class="nc">KetamaMemcachedSessionLocator</span><span class="o">)</span>
  <span class="n">clientBuilder</span><span class="o">.</span><span class="n">setCommandFactory</span><span class="o">(</span><span class="k">new</span> <span class="nc">BinaryCommandFactory</span><span class="o">)</span>
  <span class="n">clientBuilder</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">client</span> <span class="k">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build</span>
</code></pre></div>
<p>上面的代码构建了一个Memcache客户端，由于Xmemcached将每一次服务器连接抽象成了Session，所以命令行里会输出如下的语句:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">...
com.google.code.yanf4j.core.impl.AbstractController Add a session: 127.0.0.1:11211
com.google.code.yanf4j.core.impl.AbstractController Add a session: 127.0.0.1:11311
...

</code></pre></div>
<p>当我们构建客户端的时候传入了多个服务器端地址，那么在存储的时候就会涉及到选址的问题。<strong><code>net.rubyeye.xmemcached.MemcachedSessionLocator</code></strong>的多个子类提供了这一问题的解决方案，包括一致性哈希。默认情况下使用的是<strong><code>net.rubyeye.xmemcached.impl.ArrayMemcachedSessionLocator</code></strong>。以下分别对默认和一致性哈希的情况进行解析，代码是基于Scala的简化版。</p>

<h3><2> 哈希取余 -- ArrayMemcachedSessionLocator</h3>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 确定Hash策略
</span><span class="k">private</span> <span class="k">def</span> <span class="n">getHash</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">addrSize</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">hash</span> <span class="k">=</span> <span class="n">key</span><span class="o">.</span><span class="n">hashCode</span> <span class="c1">// NATIVE_HASH
</span>   <span class="n">hash</span> <span class="o">%</span> <span class="n">addrSize</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">getSessionByKey</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// 客户端连接之后会生成List[List[Session]] ，这里简化为List[List[String]]
</span>  <span class="c1">// scala&gt; new InetSocketAddress("127.0.0.1", 11211)
</span>  <span class="c1">// res7: java.net.InetSocketAddress = /127.0.0.1:11211
</span>  <span class="c1">// Memcache是基于TCP连接的，内部会构造InetSocketAddress
</span>  <span class="k">val</span> <span class="n">sessions</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"/127.0.0.1:11211"</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="s">"/127.0.0.1:11311"</span><span class="o">))</span>

  <span class="k">val</span> <span class="n">start</span> <span class="k">=</span> <span class="n">getHash</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">sessions</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">sessionListOpt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">sessions</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">find</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">sess</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">index</span> <span class="o">==</span> <span class="n">start</span>
    <span class="o">}.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">sessionListOpt</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">sessionList</span> <span class="k">=&gt;</span>
    <span class="n">sessionList</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">find</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">se</span><span class="o">,</span> <span class="n">index</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">index</span> <span class="o">==</span> <span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">sessions</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
    <span class="o">}.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
  <span class="o">}.</span><span class="n">getOrElse</span> <span class="o">{</span>
    <span class="c1">// 重算哈希的相关机制, 具体见源码实现
</span>    <span class="nc">Some</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>   
</code></pre></div>
<p style="display:none">
这种实现有一个问题，就是当Server节点增加或者是减小的时候(如果节点由N变到N + 1那么最坏的情况下有```N / (N + 1)```的数据受到影响)，这个时候如果是涉及到数据库数据的缓存，就会产生大量的查询，对服务器造成不小的压力。
</p>
    

<h3><3> <a href="https://www.quora.com/What-is-the-best-way-to-add-remove-a-new-server-in-memcached-without-restarting-it-to-avoid-rehashing-Is-it-possible">一致性哈希</a> -- KetamaMemcachedSessionLocator</h3>

<p>简单来说，就是有一个环（英文中叫Continuum），环上的每一点对应（0 ~ (2 ^ 32))之间的一个整数，通过某种哈希算法将服务器地址与环上的整数相对应，一个服务器大概对应100 ~ 200个整数(magic number)。</p>

<p><img src="https://www.adayinthelifeof.nl/images/uploads/2011/02/Screen-shot-2011-02-05-at-10.37.32-PM.png" alt="一致性Hash形成的环"></p>

<p>将要存储的Key也以某种方式进行哈希，放到环上相应的位置。如果没有找到对应的点，则按照顺时针方向往前，碰到的第一个点对应的服务器就是该Key被存储的服务器(当然还涉及到一些哈希冲突什么的)。</p>

<p><img src="https://www.adayinthelifeof.nl/images/uploads/2011/02/Screen-shot-2011-02-05-at-10.37.38-PM.png" alt="Server Hash"></p>

<p style="display:none">
这种情况下如果Memcache集群中加入一个节点，受影响的数据量为其总结点缓存量的1 / 3
    
```bash
#N为原节点数，X为新增加的节点数
affected number = X / (N + X) 
```
</p>

<p>前面我们提到了SessionLocator，它的子类<strong><code>net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator</code></strong>就是用来实现将Server节点地址映射到Continuum上的。以下是简化版代码，具体实现可参考源码。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">java.security.MessageDigest</span>

<span class="k">def</span> <span class="n">buildMap</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sessionMap</span> <span class="k">=</span> <span class="nc">TreeMap</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]()</span>

  <span class="k">val</span> <span class="n">memcachedServerAddrs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"/127.0.0.1:11211"</span><span class="o">,</span> <span class="s">"/127.0.0.1:11311"</span><span class="o">)</span>

  <span class="c1">// Xmemcached默认映射的是160个点
</span>  <span class="n">memcachedServerAddrs</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">sockStr</span> <span class="k">=&gt;</span>

    <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="mi">40</span><span class="o">).</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">num</span> <span class="k">=&gt;</span>

      <span class="k">val</span> <span class="n">digest</span> <span class="k">=</span> <span class="nc">HashAlgorithm</span><span class="o">.</span><span class="n">computeMd5</span><span class="o">(</span><span class="n">sockStr</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">num</span><span class="o">)</span> <span class="c1">// 长度为16的Array[Byte]
</span>
      <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="mi">4</span><span class="o">).</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">h</span> <span class="k">=&gt;</span>

        <span class="k">val</span> <span class="n">k</span> <span class="k">=</span> <span class="o">(</span><span class="n">digest</span><span class="o">(</span><span class="mi">3</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">).</span><span class="n">toLong</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> 
                <span class="o">(</span><span class="n">digest</span><span class="o">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">).</span><span class="n">toLong</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span> 
                <span class="o">(</span><span class="n">digest</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">).</span><span class="n">toLong</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> 
                <span class="n">digest</span><span class="o">(</span><span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>

        <span class="n">sessionMap</span> <span class="k">=</span> <span class="n">sessionMap</span> <span class="o">+</span> <span class="o">{</span>
          <span class="n">sessionMap</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">k</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">sessions</span> <span class="k">=&gt;</span>
            <span class="n">k</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">sockStr</span> <span class="o">::</span> <span class="n">sessions</span><span class="o">)</span>
          <span class="o">}.</span><span class="n">getOrElse</span> <span class="o">{</span>
            <span class="n">k</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">sockStr</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
          <span class="o">}</span>
        <span class="o">}</span>

      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">sessionMap</span>
<span class="o">}</span>    

</code></pre></div>
<p>节点散列的关键就在于计算K的那一行，但是比较尴尬的是由于水平有限，目前还不了解为什么结合布尔操作和位移操作会更均匀的分布。</p>

<p>当Server节点分布在前面提到的Continuum上之后，接下来需要做的就是按照开始提到的将Key映射到相应的节点上。关于这个过程的具体实现在<strong><code>net.rubyeye.xmemcached.impl.MemcachedConnector</code></strong>中，因为最终客户端会向Memcache服务器端发送各种请求，在Xmemcached中被封装成了Command。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">
<span class="n">public</span> <span class="nc">Session</span> <span class="n">send</span><span class="o">(</span><span class="k">final</span> <span class="nc">Command</span> <span class="n">msg</span><span class="o">)</span> <span class="n">throws</span> <span class="nc">MemcachedException</span> <span class="o">{</span>

  <span class="nc">MemcachedSession</span> <span class="n">session</span> <span class="k">=</span> <span class="o">(</span><span class="nc">MemcachedSession</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="n">findSessionByKey</span><span class="o">(</span><span class="n">msg</span>
        <span class="o">.</span><span class="n">getKey</span><span class="o">());</span>
  <span class="o">....</span>

<span class="o">}</span>

<span class="n">public</span> <span class="k">final</span> <span class="nc">Session</span> <span class="n">findSessionByKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="n">sessionLocator</span><span class="o">.</span><span class="n">getSessionByKey</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>getSessionByKey的完整实现可以参见<strong><code>KetamaMemcachedSessionLocator</code></strong>，以下为简化版的实现。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">ketamaHashKey</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">keyBytes</span> <span class="k">=</span> <span class="nc">HashAlgorithm</span><span class="o">.</span><span class="n">computeMd5</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="c1">// 取前四个byte进行操作进行哈希操作
</span>  <span class="o">(</span><span class="n">keyBytes</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">).</span><span class="n">toLong</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span> <span class="o">|</span> 
  <span class="o">(</span><span class="n">keyBytes</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">).</span><span class="n">toLong</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
  <span class="o">(</span><span class="n">keyBytes</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">).</span><span class="n">toLong</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
  <span class="o">(</span><span class="n">keyBytes</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">).</span><span class="n">toLong</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">getSessionByKey</span><span class="o">(</span><span class="n">hash</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">memcachedServerAddrs</span> <span class="k">=</span> <span class="mi">3</span>
   <span class="k">val</span> <span class="n">sessionMap</span> <span class="k">=</span> <span class="n">buildMap</span><span class="o">()</span> <span class="c1">// 调用上面的将服务器映射到Continuum的方法
</span>
   <span class="o">(</span><span class="n">sessionMap</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">hash</span><span class="o">).</span><span class="n">fold</span><span class="o">({</span>
     <span class="k">val</span> <span class="n">nextKey</span> <span class="k">=</span> <span class="n">sessionMap</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="n">hhash</span><span class="o">).</span><span class="n">firstKey</span>
     <span class="n">sessionMap</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">nextKey</span><span class="o">)</span>
   <span class="o">})(</span><span class="n">sessions</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sessions</span><span class="o">))).</span><span class="n">map</span><span class="o">(</span><span class="n">session</span> <span class="k">=&gt;</span>             
   <span class="n">session</span><span class="o">(</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">memcachedServerAddrs</span><span class="o">)))</span>
 <span class="o">}</span>
</code></pre></div>
<p>对上面的实现的简单解释: 如果hash值没有对应的服务器地址，则顺着环往下找；根据红黑树实现的话，应该是找到大于等于当前Key的最小Key，在Java中TreeMap有ceilingKey和floorKey等方法用于锁定相应的Key，Scala没有提供对应的实现，但是提供了from和to, 返回的整个子树而不是某个Key所以我们先可以找到对应的子树 然后找到最大值即可。当然在源码的实现中，还涉及到重试的机制(第一次Key找不到对应的服务器地址，则重算哈希再进行寻找)。获取List[Session]后，由于可能是多个服务器地址所以随机取一个存放即可。</p>

<p>接下来的可以做一个小小的验证，使用<strong>buildMap</strong>打印出Hash值对应的服务器地址:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">Key: 42540355 Value: /127.0.0.1:11211
Key: 52869756 Value: /127.0.0.1:11311
Key: 66469197 Value: /127.0.0.1:11311
Key: 96001103 Value: /127.0.0.1:11311
</code></pre></div>
<p>然后，往Memcache中添加Key的时候使用<strong>ketamaHashKey</strong>打印出相应的Hash值，在<strong>buildMap</strong>的结果中寻找最接近的哈希值锁定服务器地址，然后通过telnet连接Memcache服务器去进一步验证。自己写完之后验证了一下，没毛病。</p>

<p>虽然写了一大堆，但深知自己仅仅只是对于前面的Continuum是如何使用代码实现的有了一个更直观的认识。但对于一致性哈希实现的一些细节，比如说为什么通过那样的位移可以更均匀的分布等还需要进一步学习。</p>

<h2>参考</h2>

<p>&gt; <a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/">Memcache内部原理</a></p>

<p>&gt; <a href="https://www.quora.com/How-does-a-Memcache-cluster-work">Memcache集群是如何工作</a></p>

<p>&gt; <a href="http://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients">克他命一致性哈希算法解释</a></p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/cache/memcache/cluster/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/scala/path-dependent-type/" rel="prev">&laquo;&nbsp;Scala基础之路径依赖类型以及类型投影</a></div>
    
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="5308562e914c171fbd76970d1dbe71db" data-title="基于Memcached Java客户端Xmemcached的一致性哈希研究" data-url="/cache/memcache/cluster/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>