<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>从Future产生到结果收集</title>
    <meta name="description" content="本文就Future的初始化以及结果收集的过程进行了研究" />
    <meta name="keywords" content="异步计算，共享变量，链向根Promise，回调" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    从Future产生到结果收集
</p>

<h1 class="lotus-pagetit">从Future产生到结果收集</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-09-24">2015-09-24</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>Future在异步编程中使用非常广泛，Scala中的Actor就是建立在Future之上的，而Actor又在Akka和Spark中被广泛使用，重要性不言而喻。对于Future的语法和基本使用，网上已经有太多的资源了。本文想以源码为基础，就Future的结果收集进行剖析，不求多么深刻，但求能对结构收集的每一步有个大致的了解。</p>

<blockquote>
<p>A Future is a data structure used to retrieve the result of some concurrent operation. This result can be accessed synchronously (blocking) or asynchronously (non-blocking).</p>
</blockquote>

<h2><1> Future的结果 - 非阻塞式 vs 阻塞式收集</h2>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">sumResult</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">((</span><span class="mi">1L</span> <span class="n">to</span> <span class="mi">100000000L</span><span class="o">).</span><span class="n">sum</span><span class="o">)</span>
</code></pre></div>
<p>非阻塞式的取值(onComplete | onSuccess | onFailure)</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">sumResult</span> <span class="n">onComplete</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">" Future succeed "</span> <span class="o">+</span> <span class="n">sumResult</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">" Future failed"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>阻塞式的取值(Await.result)</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">sumResult</span><span class="o">,</span> <span class="nc">Duration</span><span class="o">.</span><span class="nc">Inf</span><span class="o">)</span>
</code></pre></div>
<p>使用Future的初衷是为了不阻塞，所以尽量不要使用阻塞式取值，除非你不得不这么做。在项目开发中，一般通过<strong><code>For ... Yield</code></strong>将多个Future组合起来，最后调用Await.result获取最终的结果。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">{</span>
    <span class="n">A</span> <span class="k">&lt;-</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="n">B</span> <span class="k">&lt;-</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
    <span class="n">C</span> <span class="k">&lt;-</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
    <span class="n">op</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">,</span> <span class="n">C</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>针对阻塞式的取值，以上面的代码为例就会阻塞主线程:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">scala</span>

<span class="c1">// STEP1
</span><span class="k">package</span> <span class="nn">concurrent</span> <span class="o">{</span>
    <span class="k">object</span> <span class="nc">Await</span> <span class="o">{</span>
       <span class="k">def</span> <span class="n">result</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">awaitable</span><span class="k">:</span> <span class="kt">Awaitable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">atMost</span><span class="k">:</span> <span class="kt">Duration</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
        <span class="n">blocking</span><span class="o">(</span><span class="n">awaitable</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">atMost</span><span class="o">)(</span><span class="nc">AwaitPermission</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// STEP2 
</span><span class="k">package</span> <span class="nn">object</span> <span class="n">concurrent</span> <span class="o">{</span>
   <span class="k">def</span> <span class="n">blocking</span><span class="o">(</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=</span> 
       <span class="nc">BlockContext</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">blockOn</span><span class="o">(</span><span class="n">body</span><span class="o">)(</span><span class="n">scala</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">AwaitPermission</span><span class="o">)</span>
<span class="o">}</span>


<span class="c1">// STEP3
</span><span class="k">package</span> <span class="nn">scala.concurrent</span>

<span class="k">object</span> <span class="nc">BlockContext</span> <span class="o">{</span>

    <span class="k">private</span> <span class="k">val</span> <span class="n">contextLocal</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">[</span><span class="kt">BlockContext</span><span class="o">]()</span>

    <span class="k">def</span> <span class="n">current</span> <span class="k">=</span> <span class="n">contextLocal</span><span class="o">.</span><span class="n">get</span> <span class="o">{</span>
        <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">currentThread</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">ctx</span><span class="k">:</span> <span class="kt">BlockContext</span> <span class="o">=&gt;</span> <span class="n">ctx</span>
            <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">defaultBlockContext</span>
        <span class="o">}</span>
        <span class="k">case</span> <span class="n">some</span> <span class="k">=&gt;</span> <span class="n">some</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div>
<p>在最初阅读<strong><code>current</code></strong>方法时候会疑惑，为什么<strong><code>Thread.currentThread</code></strong>会匹配<strong><code>BlockContext</code></strong>类型，源码中的解释是: 有些线程池实现的时候会让Thread继承BlockContext。</p>

<p>对于非阻塞式的取值，我们可以通过Future的相关方法来判断它的当前状态。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">sumResult</span><span class="o">.</span><span class="n">isCompleted</span>
</code></pre></div>
<p>显然<strong>onComplete</strong>，<strong>onSuccess</strong>，<strong>onFailure</strong>这些回调也是根据当前Future的状态来执行相应的操作的。那么Future内部的状态有哪几种呢？这些状态之间又是如何切换的呢？</p>

<h2><2> Future的状态以及改变</h2>

<p>要研究Future的状态变化，最好的方式就是利用<strong>onComplete</strong>的调用栈并且打断点来摸清整个调用过程，下面通过代码调用来一步一步解释(由于之前没有接触过UML图，所以可能存在一些纰漏，以下涉及到UML图的地方仅供参考)。</p>

<p><img src="/static/images/charts/2015-09-24/future_init.png" alt="Future的初始化和结果收集UML"></p>

<h3>(1) Future的初始化 -- Future.apply</h3>

<p>Future初始化的时候(实际上是DefaultPromise的初始化)，会调用<strong><code>AbstractPromise</code></strong>的updateState方法来设置初始状态。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">DefaultPromise</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AbstractPromise</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
 <span class="n">updateState</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="c1">// 实际上更新的是AbstractPromise中的_ref属性
</span><span class="o">}</span>
</code></pre></div>
<p>所以，<strong>Future初始化之后状态变成了Nil(类型实际上是List[CallbackRunnable])</strong>。</p>

<h3>(2) Future中的任务开始执行 -- PromiseCompletingRunnable</h3>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">  <span class="c1">// executor ---&gt; package scala.concurrent.impl.ExecutionContextImpl    
</span>    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">executor</span> <span class="nc">ExecutionContext</span><span class="o">)</span><span class="k">:</span> 
       <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
       <span class="cm">/*
          这里也体现了Promise的语义执行Runnable并且返回Future
          每次启动一个异步计算的时候，PromiseCompletingRunnable都会被创建一次
          body是懒加载的，所以在调用的时候才会被执行
       */</span>
       <span class="k">val</span> <span class="n">runnable</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PromiseCompletingRunnable</span><span class="o">(</span><span class="n">body</span><span class="o">)</span>

       <span class="c1">// 异步计算从这个地方开始然后调用PromiseCompletingRunnable的run方法
</span>      <span class="n">executor</span><span class="o">.</span><span class="n">prepare</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="n">runnable</span><span class="o">)</span> 

      <span class="c1">// 返回Future，实际上是DefaultPromise实例，以便后续使用，比如说Compose
</span>      <span class="n">runnable</span><span class="o">.</span><span class="n">promise</span><span class="o">.</span><span class="n">future</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>
<p>而在<strong><code>PromiseCompletingRunnable</code></strong>执行的时候，会将<strong>执行结果</strong>封装在<strong><code>Try[T]</code></strong>中，所以onComplete的回调函数的参数也是<strong>Try[T]</strong>类型的。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">PromiseCompletingRunnable</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">val</span> <span class="n">promise</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Promise</span><span class="o">.</span><span class="nc">DefaultPromise</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span>
       <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
          <span class="n">promise</span> <span class="n">complete</span> <span class="o">{</span>
              <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Success</span><span class="o">(</span><span class="n">T</span><span class="o">)</span>
              <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
                <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
              <span class="o">}</span>

          <span class="o">}</span>       
       <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h4>1. DefaultPromise.complete</h4>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 如果该Promise已经完成则报错，否则就返回DefaultPromise的当前实例
</span><span class="k">def</span> <span class="n">complete</span><span class="o">(</span><span class="n">result</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> 
  <span class="k">if</span> <span class="o">(</span><span class="n">tryComplete</span><span class="o">(</span><span class="n">result</span><span class="o">))</span> <span class="k">this</span> <span class="k">else</span> <span class="k">throw</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">"Promise already completed."</span><span class="o">)</span> 
</code></pre></div>
<h4>2. DefaultPromise.tryComplete</h4>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// tryComplete返回true则说明没有完成，返回false则说明完成
</span><span class="k">def</span> <span class="n">tryComplete</span><span class="o">(</span><span class="n">result</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">tryCompleteAndGetListeners</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">case</span> <span class="kc">null</span> <span class="k">=&gt;</span> <span class="kc">false</span>
       <span class="k">case</span> <span class="n">rs</span> <span class="k">if</span> <span class="n">rs</span><span class="o">.</span><span class="n">isEmpty</span> <span class="k">=&gt;</span> <span class="kc">true</span>
       <span class="k">case</span> <span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">rs</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">executeWithValue</span><span class="o">(</span><span class="n">result</span><span class="o">));</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h4>3. DefaultPromise.tryCompleteAndGetListeners</h4>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nd">@tailrec</span>
<span class="k">private</span> <span class="k">def</span> <span class="n">tryCompleteAndGetListeners</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">CallbackRunnable</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">getState</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">raw</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">cur</span> <span class="k">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">CallbackRunnable</span><span class="o">[</span><span class="kt">T</span><span class="o">]]]</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">updateState</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="n">cur</span> <span class="k">else</span> <span class="n">tryCompleteAndGetListeners</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>

    <span class="k">case</span> <span class="k">_:</span> <span class="kt">DefaultPromise</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="n">compressedRoot</span><span class="o">().</span><span class="n">tryCompleteAndGetListeners</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">null</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>前面提到过，<strong>DefaultPromise</strong>的状态是由<strong>AbstractPromise</strong>的<strong>_ref</strong>属性维护的。状态有以下几种:</p>

<ul>
<li><p><strong>List[CallbackRunnable[T]]</strong>(最开始的状态是Nil)。
则接下来会将<strong>DefaultPromise</strong>的状态设置成<strong>Try[T]</strong>。在sumFuture的那种情况中，模式匹配会进到这种情况。然后<strong>tryComplete</strong>返回当前<strong>DefaultPromise</strong>实例并且它的状态已经变成了<strong>Try[T]</strong></p></li>
<li><p><strong>DefaultPromise[_]</strong>(一般是调用了map, flatMap生成了新的DefaultPromise)，这里涉及到链向根DefaultPromise的过程(会在后续的更新中补充)</p></li>
<li><p>其它情况，则返回null</p></li>
</ul>

<h3>(3) Future注册回调 -- Future.onComplete</h3>

<p>Future的异步调用体现在当Future初始化之后，一个异步计算就已经开始；一般情况，我们会为Future注册相关的回调，要么是对正常的返回值进行处理，要么是对异常进行处理。同样以源码入手。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">sumResult</span> <span class="n">onComplete</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">" Future succeed "</span> <span class="o">+</span> <span class="n">sumResult</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">" Future failed"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>简化版的调用链如下:</p>

<p><img src="/static/images/charts/2015-09-24/dispatchOrAddCallback.png" alt="dispatchOrAddCallback"></p>

<h4>1. DefaultPromise.onComplete</h4>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">onComplete</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">func</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">U</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">executor</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">val</span> <span class="n">runnable</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CallbackRunnable</span><span class="o">(</span><span class="n">executor</span><span class="o">,</span> <span class="n">func</span><span class="o">)</span> <span class="c1">// 1.1
</span>    <span class="n">dispatchOrAddCallback</span><span class="o">(</span><span class="n">runnable</span><span class="o">)</span> <span class="c1">// 1.2
</span><span class="o">}</span>
</code></pre></div>
<h4>1.1 scala.concurrent.impl.CallbackRunnable</h4>

<p>因为Java中Runnable的实现(run方法)默认是返回空的，所以此处基于Runnable再实现了一个，主要的目的是为了注入回调，让Future完成之后执行该回调。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">CallBackRunnable</span><span class="o">(</span><span class="k">val</span> <span class="n">executor</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">,</span> <span class="k">val</span> <span class="n">onComplete</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Any</span><span class="o">)</span> 
     <span class="k">extends</span> <span class="nc">Runnable</span> <span class="k">with</span> <span class="nc">OnCompleteRunnable</span> <span class="o">{</span>
     <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="kc">null</span>

     <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
        <span class="c1">// 与executeWithValue中require相结合，执行run的时候value必须不为null
</span>        <span class="n">require</span><span class="o">(</span><span class="n">value</span> <span class="n">ne</span> <span class="kc">null</span><span class="o">)</span> 

        <span class="k">try</span> <span class="o">{</span>
          <span class="c1">// case Success(s) =&gt; println(" Future succeed " + sumResult)
</span>          <span class="c1">// case Failure(f) =&gt; println(" Future failed")
</span>          <span class="n">onComplete</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">NoFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">....</span>
        <span class="o">}</span>
     <span class="o">}</span>

    <span class="k">def</span> <span class="n">executeWithValue</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>

        <span class="c1">// 确保回调函数没有被多次执行
</span>        <span class="n">require</span><span class="o">(</span><span class="n">value</span> <span class="n">eq</span> <span class="kc">null</span><span class="o">)</span> 
        <span class="n">value</span> <span class="k">=</span> <span class="n">v</span>

        <span class="k">try</span> <span class="n">executor</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> 
        <span class="k">catch</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">....</span>
        <span class="o">}</span>
     <span class="o">}</span>

<span class="o">}</span>
</code></pre></div>
<h4>1.2 DefaultPromise.dispatchOrAddCallback</h4>

<p>这个方法的主要目的是获取Future的状态，从而决定是执行回调还是将回调转移给根Promise。注意这个过程中<strong><code>Future</code></strong>的执行会导致<strong><code>Promise</code></strong>的状态发生变化，也就是前面提到的<strong><code>PromiseCompletingRunnable中的run方法</code></strong>。 以sumFuture为例，</p>
<div class="highlight"><pre><code class="language-" data-lang="">private def dispatchOrAddCallback(runnable: Runnable): Unit = {
    getState match {
      case r: Try[_]          =&gt; runnable.executeWithValue(r.asInstanceOf[Try[T]])

      case _: DefaultPromise[_] =&gt; compressRoot().dispatchOrAddCallback(runnable)

      case listeners: List[_] =&gt; 
         if (updateState(listeners, runnable :: listeners)) () 
         else dispatchOrAddCallback(runnable)
    }
  }
</code></pre></div>
<p>前面提到过，<strong>DefaultPromise</strong>的状态有三种情况，在<strong>执行回调函数的线程上</strong>(Future运行和回调执行是不同的线程)通过取Future的状态来决定如何操作</p>

<ul>
<li><p><strong>Try[T]</strong> 
表示已经执行完了，可以开始执行回调函数，这个比较好理解。<strong>CallbackRunnable</strong>的<strong>executeWithValue</strong>被调用，触发<strong>run</strong>方法，从而执行<strong>onComplete</strong>中注册的回调。</p></li>
<li><p><strong>DefaultPromise[_]</strong>(一般是调用了map, flatMap生成了新的DefaultPromise)，
这里涉及到链向根DefaultPromise的过程(会在后续的更新中补充)</p></li>
<li><p><strong>List[CallbackRunnable]</strong>，
Future的初始状态是<strong>Nil(List[CallbackRunnable])</strong>，<b style="color:red">如果执行回调函数的线程在执行的时候，Future的执行并没有结束就会将Future的状态更新为List[CallbackRunnable]， 实际上注册了一个监听器(在Future执行完成之后做什么)</b>。代码中如果状态更新成功，什么都没做，返回值是<strong><code>()</code></strong>。
由于Future执行线程和回调函数执行线程共享Future的状态，所以  在<strong><code>tryCompleteAndGetListeners</code></strong>中也能捕获到状态的变化然后进入不同的操作。</p></li>
</ul>

<p>至此，一个最基本的Future初始化以及注册回调并收集结果的流程就走完了(对于，状态为DefaultPromise的情况会在后续的更新中完成)。</p>

<p>以下是本文的一些汇总:</p>

<ul>
<li><p>Future的执行和结果搜集发生在不同的线程上，Promise以及DefaultPromise中的一些方法分别在<b style="color:red">两个线程被调用但是同时修改同一个Future的状态</b>，所以能根据Future不同的状态进行不同的响应。</p></li>
<li><p>Future的状态由父类<strong>AbstractPromise</strong>中的<strong>_ref</strong>属性维护</p></li>
<li><p>Future在初始化之后的状态为<strong>List[CallbackRunnable]</strong>，执行完成之后的状态为<strong>Try[T]</strong>，如果通过map，flatMap与其它的Future产生了联系，则状态为<strong>DefaultPromise</strong>。</p></li>
</ul>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/concurrency/future/result-collect/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/spray/directive/" rel="prev">&laquo;&nbsp;Spray基础之Directive(路由)</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/http/cross-origin/" rel="next">从前到后看跨域访问&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="488b299b8446fc87aa490a28629fcd61" data-title="从Future产生到结果收集" data-url="/concurrency/future/result-collect/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>