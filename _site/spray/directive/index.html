<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Spray基础之Directive(路由)</title>
    <meta name="description" content="本文对于Spray对于Directve进行了比较详细的讲解" />
    <meta name="keywords" content="路由，指令，管道，Shapeless，响应式编程" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Spray基础之Directive(路由)
</p>

<h1 class="lotus-pagetit">Spray基础之Directive(路由)</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-05-22">2015-05-22</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>在谈论Directive之前，我们先要简单的解释一下<a href="http://spray.io/documentation/1.2.2/spray-routing/key-concepts/routes/">Routes(路由)</a>, 它的类型是<strong><code>RequestContext =&gt; Unit</code></strong>，在英文中Route是路径，路线的意思。所以在Spray中可以理解为
<b style="color:red">
 Route承担了如何处理请求的任务，将请求指派到什么流程；一般来说，它有三种方式处理请求：
 + 顺利完成请求 requestContext.complete(...)
 + 因为某种原因拒绝请求 requestContext.reject(...)
 + 因为某些异常而导致 500 Server Error
</b></p>

<p>在最开始接触Routes的时候的一个疑惑，Route函数(<strong><code>RequestContext =&gt; Unit</code></strong>)的返回值类型为什么是<strong><code>Unit</code></strong>。</p>

<blockquote>
<p>Contrary to what you might initially expect a route does not return anything. Rather, all response processing (i.e. everything that needs to be done after the route itself has handled a request) is performed in “continuation-style” via the <strong>responder of the RequestContext</strong></p>
</blockquote>

<p>一般来说，在B/S的架构中<strong>请求</strong>是和<strong>响应</strong>相对应的，如果将<strong>RequestContext</strong>视为请求上下文，那么返回值类型就应该是Response之类的。后来阅读源码之后发现，这与Spray的设计理念是有关的，它是一个基于Actor的Rest框架，相应的响应是通过<strong>消息发送</strong>传递的而且采用的是<strong>Fire-And-Forget</strong>的模式，所以返回值是<strong><code>Unit</code></strong>。后续会再写一篇文章分析Spray建立TCP连接并准备接受请求的过程，这样的话对于Spray的基本骨架会有一个清晰的认识。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">RequestContext</span><span class="o">(</span><span class="n">req</span><span class="k">:</span> <span class="kt">HttpRequest</span><span class="o">,</span> <span class="n">responder</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">,</span> 
  <span class="n">unmatchedPath</span><span class="k">:</span> <span class="kt">Uri.Path</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">complete</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">obj</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(....)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>  <span class="o">{</span>
    <span class="k">val</span> <span class="n">ctx</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ToResponseMarshallingContext</span> <span class="o">{</span>
        <span class="o">..</span>
        <span class="k">def</span> <span class="n">marshallTo</span><span class="o">(</span><span class="n">response</span><span class="k">:</span> <span class="kt">HttpResponse</span><span class="o">)</span> <span class="k">=</span> <span class="n">responder</span> <span class="o">!</span> <span class="n">response</span>
        <span class="o">..</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div>
<p>而<a href="http://spray.io/documentation/1.2.2/spray-routing/key-concepts/directives/#directives">Directive</a>从数据结构上来讲是基于<strong>Shapeless HList</strong>的高度抽象，读起来比较困难，但是理解之后会感受到类型系统的奥妙; 实际上这是Scala类型系统的一个弊端同时也是隐式转换的弊端: 学习曲线高， 太多的&quot;过程&quot;被隐藏导致的(这一点在后面的代码中会体现的更明显)。</p>

<p>从功能上来讲，它提供了各种各样的<strong>指令</strong>来构建Routes; 它的一般结构是:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">name</span><span class="o">(</span><span class="n">parameters</span><span class="o">)</span> <span class="o">{</span> <span class="n">L</span> <span class="k">=&gt;</span>
  <span class="n">innerRoute</span>
<span class="o">}</span>
</code></pre></div>
<p>PathDirective用于抽取部分URL</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">path</span><span class="o">(</span><span class="n">uid</span> <span class="o">/</span> <span class="s">"key"</span><span class="o">)</span> <span class="o">{</span> <span class="n">uid</span> <span class="k">=&gt;</span>
    <span class="n">innerRoute</span>
<span class="o">}</span>
</code></pre></div>
<p>在Restful风格的编程中，我们通常会将资源的唯一标识放在URL中，通过上面的<strong>PathDirective</strong>我们可以从URL中抽取相应的数据。上面的规则适用于该URL&quot;http://localhost/534e8effe4b078a6b660f705/uid&quot;。</p>

<p>SecurityDirective用于请求验证</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">path</span><span class="o">(</span><span class="n">uid</span> <span class="o">/</span> <span class="s">"key"</span><span class="o">)</span> <span class="o">{</span> <span class="n">uid</span> <span class="k">=&gt;</span>
    <span class="n">authorize</span> <span class="o">{</span> <span class="n">ctx</span> <span class="k">=&gt;</span>
       <span class="c1">// 获取URL参数 | 请求头等来进行权限验证
</span>       <span class="n">boolean</span>
    <span class="o">}</span> <span class="o">{</span>
      <span class="n">innerRoute</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>接下来看看几种常见的使用Directive实现<a href="http://spray.io/documentation/1.2.2/spray-routing/advanced-topics/understanding-dsl-structure/">Route的实例</a>。</p>

<h4><1> 最基本的Route实现</h4>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// get的类型是Directive0
</span><span class="n">get</span> <span class="o">{</span>
  <span class="c1">// complete的类型: ToResponseMarshallable =&gt; StandRoute
</span>  <span class="c1">// Spray提供了很多隐式转换将不同类型转换成ToResponseMarshallable，String正是其中之一
</span>  <span class="c1">// complete("")的类型是 RequestContext =&gt; Unit
</span>  <span class="n">complete</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p><strong><code>HttpServiceBase</code></strong>要求所有的子类调用<strong><code>runRoute</code></strong>方法的时候提供<strong><code>Route</code></strong>函数实例</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"> <span class="c1">// type Route = RequestContext =&gt; Unit
</span> <span class="k">trait</span> <span class="nc">HttpServiceBase</span> <span class="k">extends</span> <span class="nc">Directives</span> <span class="o">{</span>
   <span class="k">def</span> <span class="n">runRoute</span><span class="o">(</span><span class="n">route</span><span class="k">:</span> <span class="kt">Route</span><span class="o">)(...)</span> <span class="o">{}</span>
 <span class="o">}</span>
</code></pre></div>
<p>再来看一下抽象类<strong><code>Directive</code></strong>的基本结构:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Diretive</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// L的类型为HNil
</span>  <span class="k">def</span> <span class="n">happly</span><span class="o">(</span><span class="n">func</span><span class="k">:</span> <span class="kt">L</span> <span class="o">=&gt;</span> <span class="nc">Route</span><span class="o">)</span><span class="k">:</span> <span class="kt">Route</span>
  <span class="c1">// 组合操作
</span>  <span class="k">def</span> <span class="o">&amp;(</span><span class="n">magnet</span><span class="k">:</span> <span class="kt">ConjunctionMagnet</span><span class="o">)</span><span class="k">:</span> <span class="kt">magnet.OUT</span> <span class="o">=</span> <span class="n">magnet</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Directive</span> <span class="o">{</span>
    <span class="cm">/*
        H的类型: HNil
        hac.apply的类型: def apply(in: Route): HNil =&gt; Route
        hac.In的类型 =&gt; Route: Route =&gt; Route
        hac(f)的类型 HNil =&gt; Route
        happly(HNil =&gt; Route)的类型: Route
    */</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">pimpApply</span><span class="o">[</span><span class="kt">H</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">directive</span><span class="k">:</span> <span class="kt">Directive</span><span class="o">[</span><span class="kt">H</span><span class="o">])</span>
        <span class="o">(</span><span class="k">implicit</span> <span class="n">hac</span><span class="k">:</span> <span class="kt">ApplyConveter</span><span class="o">[</span><span class="kt">H</span><span class="o">])</span><span class="k">:</span> <span class="kt">hac.In</span> <span class="o">=&gt;</span> <span class="nc">Route</span> <span class="k">=</span> <span class="o">{</span>
        <span class="n">f</span> <span class="k">=&gt;</span> <span class="n">directive</span><span class="o">(</span><span class="n">happly</span><span class="o">(</span><span class="n">hac</span><span class="o">(</span><span class="n">f</span><span class="o">)))</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Directiv0实例经由Directive中的隐式方法pimpApply被转换:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">ApplyConverter</span><span class="o">[</span><span class="kt">L</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">In</span>
    <span class="c1">// L的类型为HNil 所以apply的返回值: HNil =&gt; Route
</span>    <span class="c1">// In的类型为Route
</span>    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">In</span><span class="o">)</span><span class="k">:</span> <span class="kt">L</span> <span class="o">=&gt;</span> <span class="nc">Route</span> 
<span class="o">}</span>

<span class="c1">// 这种模式在Spray中大量使用，伴生对象并没有直接继承伴生类
// 而是继承了另外一个提供了伴生类实例的类或特质
</span><span class="k">object</span> <span class="nc">ApplyConverter</span> <span class="k">extends</span> <span class="nc">ApplyConverterInstances</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">hac0</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ApplyConverter</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">type</span> <span class="kt">In</span> <span class="o">=</span> <span class="nc">Route</span>

        <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">fn</span><span class="k">:</span> <span class="kt">In</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">HNil</span> <span class="k">=&gt;</span> <span class="n">fn</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>最终Get的类型为<strong><code>Route =&gt; Route</code></strong>，而complete(&quot;&quot;)类型是<strong><code>StandardRoute</code></strong>，函数调用的结果是<strong><code>Route</code></strong>，正好是<strong><code>runRoute</code></strong>方法所需要的。</p>

<h4><2> 使用Directive组合操作来实现Route</h4>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">path</span><span class="o">(</span><span class="s">"xx"</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">authorize</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
</code></pre></div>
<p>上述操作是一个简单的Directive组合操作，目的是为了在路径匹配之后增加额外的验证; 比如说为App提供API的话，每一次请求除了要验证Path，还需要验证相应的权限。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// ConjunctionMagnet
</span><span class="k">trait</span> <span class="nc">ConjunctionMagnet</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">OUT</span> 
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">underlying</span><span class="k">:</span> <span class="kt">Directive</span><span class="o">[</span><span class="kt">L</span><span class="o">])</span><span class="k">:</span> <span class="kt">OUT</span>
<span class="o">}</span>

<span class="c1">// 这里伴生对象又没有直接继承伴生类(这种模式上面已经提到过了)
// prepender提供了进一步的拼接操作; prepender.Out拼接之后的结果(HList)
</span><span class="k">object</span> <span class="nc">ConjunctionMagnet</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">fromDirecive</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">R</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">other</span><span class="k">:</span> <span class="kt">Directive</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span>
    <span class="o">(</span><span class="k">implicit</span> <span class="n">prepender</span><span class="k">:</span> <span class="kt">Prepender</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>

       <span class="k">new</span> <span class="nc">Directive</span><span class="o">[</span><span class="kt">prepender.Out</span><span class="o">]</span> <span class="o">{</span>
         <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Directive</span><span class="o">[</span><span class="kt">prepender.Out</span><span class="o">]</span>
         <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Directive</span><span class="o">[</span><span class="kt">L</span><span class="o">])</span><span class="k">:</span> <span class="kt">Out</span> <span class="o">=</span> <span class="o">{</span>
           <span class="k">new</span> <span class="nc">Directive</span><span class="o">[</span><span class="kt">prepender.Out</span><span class="o">]</span> <span class="o">{</span>
             <span class="k">def</span> <span class="n">happly</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">prepender.Out</span> <span class="o">=&gt;</span> <span class="nc">Route</span><span class="o">)</span><span class="k">:</span> <span class="kt">Route</span> <span class="o">=</span> <span class="o">{</span>
               <span class="n">left</span><span class="o">.</span><span class="n">happly</span> <span class="o">{</span> <span class="n">l</span> <span class="k">=&gt;</span>
                 <span class="n">right</span><span class="o">.</span><span class="n">happly</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span>
                    <span class="n">f</span><span class="o">(</span><span class="n">prepender</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span>
                 <span class="o">}</span>
               <span class="o">}</span>
             <span class="o">}</span>
           <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h4><3> 使用Future Directive来实现Route</h4>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">
<span class="k">val</span> <span class="n">routes</span><span class="k">:</span> <span class="kt">spray.routing.Route</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">get</span> <span class="o">{</span>
    <span class="c1">// Normally T is a case class
</span>    <span class="n">onSuccess</span><span class="o">(..</span> <span class="nc">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]..)</span> <span class="o">{</span>
        <span class="c1">// T =&gt; Route =&gt; Route
</span>        <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">complete</span><span class="o">(</span><span class="s">"t"</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div>
<p><img src="/static/images/charts/2015-05-21/FutureDirective.png" alt="Future Directive简单流程"></p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">OnSuccessFutureMagnet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span> <span class="k">&lt;:</span> <span class="kt">HList</span>
  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">Directive</span><span class="o">[</span><span class="kt">Out</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">OnSuccessFutureMagnet</span> <span class="o">{</span>
 <span class="k">implicit</span> <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">future</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">hl</span><span class="k">:</span> <span class="kt">HListable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span>
   <span class="k">new</span> <span class="nc">Directive</span><span class="o">[</span><span class="kt">hl.Out</span><span class="o">]</span> <span class="k">with</span> <span class="nc">OnSuccessFutureMagnet</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="nc">Out</span>
    <span class="o">...</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>上面<strong><code>HListable[T]</code></strong>的实现还是挺有意思，基本规则如果<strong><code>T &lt;: HList</code></strong>，直接返回，否则 使用<code>T :: HNil</code>构建新的<strong><code>HList</code></strong>，下面模仿它的实现思想，实现一个<strong><code>Listable</code></strong>。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Listable</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
   <span class="k">type</span> <span class="kt">Out</span> <span class="k">&lt;:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
   <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Out</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Listable</span> <span class="k">extends</span> <span class="nc">LowerpriorityListable</span> <span class="o">{</span>
   <span class="k">implicit</span> <span class="k">def</span> <span class="n">fromList</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Listable</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
     <span class="k">override</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">T</span>
     <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">t</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">LowerpriorityListable</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">fromAnyRef</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Listable</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">import</span> <span class="nn">scala.collection.immutable.</span><span class="o">::</span>
      <span class="k">override</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="o">::[</span><span class="kt">T</span><span class="o">]</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Out</span> <span class="o">=</span> <span class="o">::(</span><span class="n">t</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>在HListable实现过程中，有一个地方需要注意:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">LowerpriorityHListable</span> <span class="o">{</span> 
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">fromAnyRef</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HListable</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">T</span> <span class="o">::</span> <span class="nc">HNil</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">t</span> <span class="o">::</span> <span class="nc">HNil</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">+H</span>, <span class="kt">+T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">H</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">HList</span> <span class="o">{}</span>
</code></pre></div>
<p>Out类型的定义实际上用到了中置操作符(Infix Operations): <strong><code>T :: HNil =&gt; ::[T, Nil]</code></strong>，实际上就是生成了::类型。</p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/spray/directive/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/mongodb/aggregation/" rel="prev">&laquo;&nbsp;MongoDB基础之聚合(aggregation)</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/concurrency/future/result-collect/" rel="next">从Future产生到结果收集&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="648a1d4bee718608389fbafe9c484311" data-title="Spray基础之Directive(路由)" data-url="/spray/directive/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>