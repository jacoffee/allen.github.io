<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Scala基础之隐式转换(implicit-conversion)</title>
    <meta name="description" content="本文研究了隐式转换，隐式参数, 视界的概念以及Scala编译器寻找隐式类型的顺序" />
    <meta name="keywords" content="隐式转换,隐式方法,隐式类,视界,类型参数" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Scala基础之隐式转换(implicit-conversion)
</p>

<h1 class="lotus-pagetit">Scala基础之隐式转换(implicit-conversion)</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-02-08">2015-02-08</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>最初学习Scala的时候对隐式转换这个概念印象特别深，因为它可以进行自动类型转换，方法调用还有增强类的功能，还有隐式参数（就是Scala编译器自动帮你传进去的参数），所以现在想借此机会将隐式转换以及隐式参数这个知识点进行系统的梳理，同时也会总结个人在学习中的一些心得。</p>

<h1>问题</h1>

<p>隐式转换，隐式参数是什么？隐式类型分为哪些？Scala编译器是按照什么顺序去寻找隐式类型的？</p>

<h1>解决</h1>

<p>隐式转换指的是Scala编译器会帮助完成指定的&quot;转换&quot;，从而减少重复代码并且在一定程度上扩展现有library的功能。隐式参数就是不需要你显示传递参数(Scala编译器会帮你完成当然你也可以显示的传递)。</p>

<p><1> 减少重复代码</p>

<p>在Java的Swing中我们会给组件注册监听事件，通常会有如下代码:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">JButton</span> <span class="n">button</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JButton</span><span class="o">(</span><span class="s">"press me"</span><span class="o">);</span>
<span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ActionListener</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Click"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div>
<p>如果以Scala的角度考虑(函数式)， 我们可以看出ActionListener中代码是非常模式化的，就是生成ActionListerner的实例并且重写actionPerformed方法。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">    <span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">({</span>
        <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"I am pressed"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="c1">// 但是这种写法会报编译类型错误的
</span>
    <span class="c1">// 增加隐式方法为我们完成这次转换
</span>    <span class="k">implicit</span> <span class="k">def</span> <span class="n">actionEventFuncToActionListener</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">ActionEvent</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span>
        <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
            <span class="k">override</span> <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="c1">// 那么当编译器去编译上面的代码，开始不通过然后去搜索隐式转换，编译通过
</span>    <span class="c1">// 特别注意隐式方法有点先定义后使用的感觉，
</span>    <span class="c1">// 就是actionEventFuncToActionListener一定要定义
</span>    <span class="c1">// 在button.addActionListener之前，当然这个之前不仅仅指的是代码的位置。
</span></code></pre></div>
<p>所以隐式转换很好的避免了，每次注册监听事件都要重复书写ActionListener的实现。</p>

<p><2> 功能扩展</p>

<p>比如说我们想扩展某个jar中类的功能，就可以采用此方法。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 给String添加新方法
</span><span class="k">class</span> <span class="nc">StringImprovement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">increment</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">one</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">one</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">toChar</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">stringIncrement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringImprovement</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>

<span class="s">"abc"</span><span class="o">.</span><span class="n">increment</span>
<span class="c1">// "abc"默认的是没有increment方法，这次隐式转换就会去搜索哪个类有这个方法然后，将string转换成StringImprovement
</span>
<span class="c1">//还有一个更为常见的就是
</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"one"</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">"two"</span><span class="o">)</span> 

<span class="c1">// 下面的隐转使上面的书写更简洁和达意
</span><span class="k">package</span> <span class="nn">scala</span>
<span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
    <span class="k">class</span> <span class="nc">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">def</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">y</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Tuple2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">any2ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">ArrowAssoc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div>
<h3>隐式类型</h3>

<p><1> 隐式转换</p>

<p>这个上面已经提到了，就是如果class C的某个实例o调用了方法m，即o.m, 但实际上o并没有m方法。这时候Scala编译器就会去寻找能够把o转成支持m方法调用的一个类型。</p>

<p><2> 隐式参数</p>

<p>编译器会自动帮你传递这个参数，如果找不到就会报错。简单来说就是someCall(a)在实际调用的时候会变成someCall(a)(b)。</p>

<p>举个例子，网站用户登录之后一般都会有问候语什么的但一般是固定的。我们可以用隐式参数来模拟。</p>

<p>eg:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Welcome</span><span class="o">(</span><span class="k">val</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">greet</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">welcome</span><span class="k">:</span> <span class="kt">Welcome</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
        <span class="n">s</span><span class="s">"${name}, ${welcome}"</span> 
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Explicit Invocation
</span><span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">"allen"</span><span class="o">)(</span><span class="k">new</span> <span class="nc">Welcome</span><span class="o">(</span><span class="s">"欢迎回来"</span><span class="o">))</span>

<span class="c1">// Implicit Invocation
</span><span class="k">object</span> <span class="nc">GreetingSetting</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">welcome</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Welcome</span><span class="o">(</span><span class="s">"欢迎回来"</span><span class="o">)</span>
<span class="o">}</span> 

<span class="c1">//引入隐式参数
</span><span class="k">import</span> <span class="nn">GreetingSetting._</span>
<span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">"allen"</span><span class="o">)</span>
</code></pre></div>
<p>使用隐式参数避免了一些重复的显示调用并且使代码更简洁。另外上面那个例子我们实际上需要输出的是一个字符串，但是传进去的是一个Type，实际上这样的隐式参数灵活性也是比较好的。而这种写法也在Programming In Scala中提到了</p>

<blockquote>
<p>A style rule for implicit parameters。As a style rule, it is best to use a <b style="color:red">custom named type in the types of implicit parameters.</b> For example, the types of welcome in the previous example was not String, but Welcome。</p>

<p>Thus the style rule: use at least one role-determining name within the type of an implicit parameter(这句话告诉我们隐式参数的类型命名应该是达意的，让人一下就看出来它是干什么的).</p>
</blockquote>

<p>Scala的CanBuildFrom就是一个不错的例子
```scala
trait CanBuildFrom[-From, -Elem, +To] {}</p>

<p>def map<a href="f:%20A%20=%3E%20B">B, That</a>(implicit bf: CanBuildFrom[Repr, B, That]): That = {}
```</p>

<p><3> 视界(View Bound)
说实话，我感觉有些技术术语翻译成中文之后总感觉怪怪的，就像&quot;视界&quot;第一眼看到根本不知道是干什么的。
对于O &lt;% T, 只要O可以被&quot;当作&quot;T，那么我就可以随意使用O。</p>

<p>eg:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 从List[T]中寻找最大的T, Ordered是Scala Library的一个用于比较元素"大小"的特质
</span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">orderer</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"empty list!"</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">head</span>
        <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">tail</span><span class="o">)</span> <span class="c1">// maxList(tail)(orderer) 
</span>            <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">&gt;</span> <span class="n">maxRest</span><span class="o">)</span> <span class="n">head</span> <span class="c1">// orderer(head).&gt;(maxRest)
</span>            <span class="k">else</span> <span class="n">maxRest</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 上面的orderer是一个转换的函数，
// Scala Compiler提供了一种更简单的简洁的写法: View Bound
</span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;%</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"empty list!"</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">head</span>
        <span class="k">case</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">tail</span><span class="o">)</span> <span class="c1">// maxList(tail)(orderer) 
</span>            <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">&gt;</span> <span class="n">maxRest</span><span class="o">)</span> <span class="n">head</span> <span class="c1">// orderer(head).&gt;(maxRest)
</span>            <span class="k">else</span> <span class="n">maxRest</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 运用: 找出年龄最大的女生
</span><span class="k">class</span> <span class="nc">Girl</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">Girl</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Girl</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">age</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="n">age</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">girls</span> <span class="k">=</span> <span class="nc">Girl</span><span class="o">(</span><span class="s">"zml"</span><span class="o">,</span> <span class="mi">27</span><span class="o">)</span> <span class="o">::</span>  <span class="nc">Girl</span><span class="o">(</span><span class="s">"allen"</span><span class="o">,</span> <span class="mi">25</span><span class="o">)</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">maxList</span><span class="o">(</span><span class="n">girls</span><span class="o">)</span>
</code></pre></div>
<p>其实上面这种写法还不能精确的传达View Bound的含义，实际上使用的Upper Bound因为我使用的是Ordered的子类。但根据View Bound的定义，只要可以被当做Ordered类型的都可以传入，Girl当然可以被传进去。</p>

<p>下面举一个更贴切的例子，通过隐转满足视界:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">getIndex</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">CC</span><span class="o">](</span><span class="n">seq</span><span class="k">:</span> <span class="kt">CC</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">conv</span><span class="k">:</span> <span class="kt">CC</span> <span class="o">=&gt;</span> <span class="nc">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> 
    <span class="k">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">indexOf</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
<span class="k">def</span> <span class="n">getIndexViaContextBound</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">CC</span> <span class="k">&lt;%</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">seq</span><span class="k">:</span> <span class="kt">CC</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> 
    <span class="k">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">indexOf</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>

<span class="n">getIndexViaContextBound</span><span class="o">(</span><span class="s">"abc"</span><span class="o">,</span> <span class="sc">'c'</span><span class="o">)</span>
</code></pre></div>
<p>Scala编译器会首先找到下面的隐转</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">implicit</span> <span class="k">def</span> <span class="n">wrapString</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">WrappedString</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="n">ne</span> <span class="kc">null</span><span class="o">)</span> <span class="k">new</span> <span class="nc">WrappedString</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">else</span> <span class="kc">null</span>

<span class="k">class</span> <span class="nc">WrappedString</span><span class="o">(</span><span class="k">val</span> <span class="n">self</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AbstractSeq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> 
<span class="k">with</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">with</span> <span class="nc">StringLike</span><span class="o">[</span><span class="kt">WrappedString</span><span class="o">]</span> <span class="o">{</span>
<span class="c1">// IndexSeq 是有indexOf方法的
// "abc" -&gt;  wrapString("abc")
</span></code></pre></div>
<p><3> Type class with implicits</p>

<blockquote>
<p>One thing that you can achieve with type classes and not with implicit conversions is adding properties to a type, rather than to an instance of a type. You can then access these properties even when you do not have an instance of the type available.</p>
</blockquote>

<p>Normally, in order to add properties with implicit conversion we have to <strong><code>create a instance of that type with the property on the fly</code></strong>, i.e, instance of that type is a must.</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">
<span class="k">trait</span> <span class="nc">FKTC</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>

<span class="c1">// companion here is for Scala Compiler to find 
</span><span class="k">object</span> <span class="nc">FKTC</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">defaultInt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FKTC</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">value</span> <span class="k">=</span> <span class="mi">5</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">listInt</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">FKTC</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FKTC</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
     <span class="k">def</span> <span class="n">value</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">FKTC</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="n">value</span> <span class="o">::</span> <span class="nc">Nil</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">FKTCTest</span> <span class="o">{</span>

    <span class="c1">// This is to verify the rules of implicit look up
</span>    <span class="k">implicit</span> <span class="k">val</span> <span class="n">defaultInt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FKTC</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">value</span> <span class="k">=</span> <span class="mi">43</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">default</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">FKTC</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">FKTC</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="n">value</span>
<span class="o">}</span>

</code></pre></div><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// Attention, if we don't explicitly import defaultInt in FKTCTest,
// Scala compiler will still try to find implicit in FKTC's companion object
// Then we can add value property to a type T
// List(5)
</span><span class="nc">FKTCTest</span><span class="o">.</span><span class="n">default</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> 

<span class="c1">// See, we can even add property for higher-kinded type
// List(List(5))
</span><span class="nc">FKTCTest</span><span class="o">.</span><span class="n">default</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> 

<span class="cm">/*
    List[List[Int]] =&gt; 
    implicitly[FKTC[List[  List[Int] ]]] =&gt;

    // T =&gt; List[Int]
    listInt[T: FKTC] =&gt; new FKTC[List[ List[Int] ]] {
        def value = FKTCTest.default[List[Int]] :: Nil
    }
*/</span>

</code></pre></div>
<h3>隐式类型的规则</h3>

<p><1> 只有使用implicit标记的定义(val, def, class)才会被编译器当作隐式类型去使用</p>

<p><2> 插入的隐式转换必须以单一标识符的形式存在于作用域中，或是与源类型或目标类型相关联。</p>

<p>前半句的意思就是x + y可以被转换成 convert(x) + y, 但是不会被转换成SomeVariable.convert(x) + y。如果非要使用后一种必须要显示的引入进来。</p>

<p>后半句的意思是：</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Dollar</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">dollarToEuro</span><span class="o">(</span><span class="n">dollar</span><span class="k">:</span> <span class="kt">Dollar</span><span class="o">)</span><span class="k">:</span> <span class="kt">Euro...</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Euro</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">dollarToEuro</span><span class="o">(</span><span class="n">dollar</span><span class="k">:</span> <span class="kt">Dollar</span><span class="o">)</span><span class="k">:</span> <span class="kt">Euro...</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Dollar</span> <span class="o">{}</span>

<span class="k">def</span> <span class="n">testCompanionScope</span><span class="o">(</span><span class="n">euro</span><span class="k">:</span> <span class="kt">Euro</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div>
<p>如上面的代码，如果某个需要一个Euro作为参数方法被传入了Dollar类型的，这时Scala编译器会搜索Dollar(源类型)或Euro(目标类型)的<b style="color:red">伴生对象</b>。</p>

<p><3> 需要隐式类型的地方，一次只能进行一次转换</p>

<p>也就是不可能有x + y被编译器隐式转换成 convert1(convert2(x)) + y, 这种写法会导致实际运行的代码跟你预期的有很大的不同，而且使代码变得不清晰。</p>

<p><4> 如果<b style="color:red">通过编译器检测</b>，那么隐式类型便不会被用到</p>

<p><5> 如果某个作用域有多个隐式转换，我们可以通过显示的声明来控制哪个隐式转换需要用到</p>

<h3>隐式类型的寻找</h3>

<p><1> 搜索当前作用域</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">implicit</span> <span class="k">val</span> <span class="n">limit</span> <span class="k">=</span> <span class="mi">10</span>
<span class="k">def</span> <span class="n">paginateByXX</span><span class="o">(</span><span class="n">search</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">limit</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div>
<p><2> 显示的引入</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">scala.collection.JavaConversions.mapAsScalaMap</span> 
<span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">getenv</span>
<span class="n">env</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span>
</code></pre></div>
<p><3> 某个类型的伴生对象(Dollar, Euro所描述的)</p>

<p><4> 在类型参数中寻找</p>

<p>eg1: Scala类库中的sorted</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">B</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{}</span>
<span class="k">object</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">n</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nc">List</span><span class="o">(</span><span class="k">new</span> <span class="n">A</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="k">new</span> <span class="n">A</span><span class="o">(</span><span class="mi">5</span><span class="o">)).</span><span class="n">sorted</span>
<span class="c1">// def sorted[B &gt;: A](implicit ord: Ordering[B]): Repr...
</span></code></pre></div>
<p>很明显上面的sorted方法需要传入一个隐式的ord参数，但是Ordering[A]根本没有这样的转换，这时候Scala编译器就会去类型参数A中去寻找即A的<b style="color:red">伴生对象</b>中定义的ord。</p>

<h1>结语</h1>

<p>Scala的隐式类型还是比较复杂的并且涉及到很多类型方面的知识。尽管它为我们提供了很多编程方面的便利，但是在使用时还是需要谨慎，注意作用域否则就可能带来意想不到的&quot;转换&quot;</p>

<h1>参考</h1>

<p><1> <a href="http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html">Finding Implicits</a></p>

<p><2> Programming In Scala - Implicit Conversions and Parameters(Chapter 21)</p>

<p><3> <a href="http://stackoverflow.com/questions/8524878/implicit-conversion-vs-type-class">Implicit Conversion VS Type Class</a></p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/scala/implicits/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/scala/static-forwarder/" rel="prev">&laquo;&nbsp;Scala基础之静态代理(static forwarder)</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/scala/type-class/" rel="next">Scala基础之类型类(type class pattern)&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="dde9e45d61a77e15ceb5bbf9cfa1e6ac" data-title="Scala基础之隐式转换(implicit-conversion)" data-url="/scala/implicits/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>