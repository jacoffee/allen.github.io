<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Scala基础之类型类(type class pattern)</title>
    <meta name="description" content="本文研究了Haskell类型类的概念以及类型类的概念在Scala Context Bound的运用" />
    <meta name="keywords" content="Haskell，类型类，上下文定界" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Scala基础之类型类(type class pattern)
</p>

<h1 class="lotus-pagetit">Scala基础之类型类(type class pattern)</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-02-11">2015-02-11</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>前几天在写<a href="/scala/implicits/">Scala基础之隐式转换</a>的时候，在隐式类型中实际上还有一种叫Context Bound(上下文定界)，由于当时涉及到另外一个概念Type class pattern(类型类)并且自己不熟，所以并没有写出来。今天特意研究了一下，决定写下来。</p>

<h1>问题</h1>

<p>什么是类型类？它在Scala中的主要应用是什么？</p>

<h1>解决</h1>

<h3 style="text-indent: 25px;">基本概念</h3>

<p>首先Type class pattern是来源于Haskell的, 一种纯函数式的语言。Scala从它里面借鉴了很多思想。
由于本人也没有学习过Haskell，所以下面主要介绍类型类的思想，如果对于Haskell感兴趣的话，可以去这个网站上<a href="http://rwh.readthedocs.org/en/latest/">Real World Haskell</a>看看。</p>

<blockquote>
<p>Typeclasses define a set of functions that can have different implementations depending on the type of data they are given</p>
</blockquote>

<p>类型类定义了一套函数，它们会根据类型的不同而有不同的实现。</p>

<p>eg1: 比较颜色的不同，Haskell的作者并<b style= "color: red">没有提供&quot;==&quot;方法</b>(感觉有点不可思议)，所以需要自己定义。</p>
<div class="highlight"><pre><code class="language-Haskell" data-lang="Haskell">data Color = Red | Green | Blue

colorEq :: Color -&gt; Color -&gt; Bool 
/*
    类似于Scala中的
    def colorEq(c1: Color, c2: Color): Boolean
*/
colorEq Red   Red   = True
colorEq Green Green = True
colorEq Blue  Blue  = True
colorEq _     _     = False

// 调用
colorEq Red Green // false
colorEq Green Green // true
</code></pre></div>
<p>eg2: 比较各种角色是否相同</p>
<div class="highlight"><pre><code class="language-Haskell" data-lang="Haskell">data Role = Boss | Manager | Employee

roleEq :: Role -&gt; Role -&gt; Bool
roleEq Employee Employee = True
roleEq Manager Manager = True
roleEq Boss Boss = True
roleEq _ _  = False

// 调用
roleEq Employee Employee // true
roleEq Employee Boss // false
</code></pre></div>
<p>上面两种写法分别针对Color和Role类型进行相等性的比较，如果有更多的类型需要进行相等性的比较，<strong>那我们需要定义更多的相等性比较的规则</strong>。</p>

<p>如果能定义一套通用的函数就是<b style="color:red">用于比较</b>，那么我们代码的通用性也会增强。只需要让编译器知道如何对传入的类型进行比较即可。</p>
<div class="highlight"><pre><code class="language-Haskell" data-lang="Haskell">-- Haskell的class与一般语言的class不是同一个概念，它用于定义类型类
class BasicEq x where
    isEqual x -&gt; x -&gt; Bool
</code></pre></div>
<p><b style="color:red">上面可以理解为对于任何类型x，只要它是BasicEq的实例，isEqual就会接收两个x类型的参数并且返回Bool。</b></p>

<p>下面定义一种类型类的实例，我们为Bool和之前的Color定义是否相等的规则。</p>
<div class="highlight"><pre><code class="language-Haskell" data-lang="Haskell">instance BasicEq Bool where
    isEqual True True = True 
    isEqual False False = True 
    isEqual _ _ = False 

instance BasicEq Color where
    isEqual Red   Red   = True
    isEqual Green Green = True
    isEqual Blue  Blue  = True
    isEqual _     _     = False
</code></pre></div>
<p>按照上面的情况，我们可以用isEqual去比较<b style="color:red">任何类型</b>，只要传入的类型是BasicEq的实例。这种结论正好呼应了开头提到的类型类的概念，定义一套函数(isEqual)，根据类型不同(Bool, Color)而有不同的实现(Bool类型相等的规则和Color相等的规则是不一样的)。</p>

<h3 style="text-indent: 25px;"> 在Context Bound(上下文定界)中的应用</h3>

<blockquote>
<p>Context bounds were introduced in Scala 2.8.0, and are typically used with the so-called type class pattern, a pattern of code that emulates the functionality provided by Haskell type classes, though in a more verbose manner.</p>
</blockquote>

<p>上下文定界是在Scala 2.8中引入进来的，它通常被当作类型类去使用，实际上是从Haskell中借鉴的但是用了<b style="color:red">更繁杂的方法</b>去实现的。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">g</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</code></pre></div>
<p><b style="color:red">对于任何类型A，都有一个隐式转换使之变成B[A]。然后调用B[A]的某个方法g，并且传入类型为A的参数a。</b></p>

<p>eg: scala.math.Ordered就是一个比较典型的例子</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">simpleF</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">]].</span><span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>

<span class="n">simpleF</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="c1">// -1 即 3 &lt; 4   
</span></code></pre></div>
<p>simpleF还有一种等价的写法。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">verboseF</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span><span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">// public static &lt;A&gt; boolean verboseF(A paramA1, A paramA2, Ordering&lt;A&gt; paramOrdering)
</span>    <span class="k">import</span> <span class="nn">ord._</span> <span class="c1">// 引入Ordering中的隐转
</span>    <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="c1">// ord.mkOrderingOps(x)
</span><span class="o">}</span>
</code></pre></div>
<p>针对上面那个例子，有三点需要说明。</p>

<p><1> simpleF的Ordering没有带参数类型，因为它实际上是verboseF的语法糖。</p>

<p><2> implicitly是为了获取我们需要的类型Ordered[A]，有点&quot;显示&quot;触发隐转的味道。</p>

<p><3> Int =&gt; Ordered[Int]的过程</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// Int =&gt; RichInt, 这个隐转定义在LowPriorityImplicits中，
// 并且被Predef继承。另外RichInt实际上是Ordered的子类。
</span><span class="nd">@inline</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intWrapper</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="n">runtime</span><span class="o">.</span><span class="nc">RichInt</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>这样Int是Ordered的&quot;间接实例&quot;(因为Int被转换成了RichInt，这也就是上面所说的更繁杂的意思吧)，所以Int可以被作为参数传进去。</p>

<blockquote>
<p>Basically, this pattern implements an alternative to inheritance by making functionality available through a sort of implicit adapter pattern.</p>
</blockquote>

<p>这种类型类的方式就好像给继承提供了一种补充方案，Int并不是Ordered[Int]的实例。但是通过隐转，Int就能够作为类型A被传进去。</p>

<h1>结语</h1>

<p>一时语塞，尽在文中。</p>

<h1>参考</h1>

<p><1> <a href="http://stackoverflow.com/questions/7669627/scala-source-implicit-conversion-from-int-to-richint">Int to RichInt</a></p>

<p><2> <a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">Context and View Bound</a></p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/scala/type-class/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/scala/implicits/" rel="prev">&laquo;&nbsp;Scala基础之隐式转换(implicit-conversion)</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/scala/value-types/" rel="next">Scala基础之值类型(value types)&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="45e8dc0d31da82335dc1f50ae63c3f33" data-title="Scala基础之类型类(type class pattern)" data-url="/scala/type-class/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>