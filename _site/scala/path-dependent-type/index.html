<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Scala基础之路径依赖类型以及类型投影</title>
    <meta name="description" content="本文研究了Scala的路径依赖以及类型投影" />
    <meta name="keywords" content="路径依赖类型，类型投影，类型相等检验" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Scala基础之路径依赖类型以及类型投影
</p>

<h1 class="lotus-pagetit">Scala基础之路径依赖类型以及类型投影</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2016-03-07">2016-03-07</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>在Scala中我们经常会使用<strong>O.T</strong>(路径依赖类型)以及<strong>O#T</strong>(类型投影)来表达类型。由于Scala中有强大的类型系统加上平时很少去封装一些复杂的结构，所以并没有系统地去了解这两种类型的区别。</p>

<h3>路径依赖类型</h3>

<p>它可以看做是对象的成员所指向的类型(Scala In Depth 中有这样一句话 It refers to a type found on a specific object instance)，之所以路径依赖是因为如果<strong>没有对象或者是类的实例</strong>，那路径依赖类型也无从谈起；另外一点就是由于依赖了当前的实例，所以<strong>该类型便不能绑定在其它的实例上</strong>。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span>
    <span class="k">trait</span> <span class="nc">Inner</span> 
    <span class="k">def</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Inner</span> <span class="o">{}</span>
    <span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">this.Inner</span><span class="o">)</span> <span class="k">=</span> <span class="kc">null</span>
    <span class="k">def</span> <span class="n">bar</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Outer</span><span class="k">#</span><span class="kt">Inner</span><span class="o">)</span> <span class="k">=</span> <span class="kc">null</span>
<span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Outer</span> <span class="o">=</span> <span class="nc">Outer</span><span class="k">@</span><span class="mi">7960847</span><span class="n">b</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Outer</span> <span class="o">=</span> <span class="nc">Outer</span><span class="k">@</span><span class="mf">2d</span><span class="n">b0f6b2</span>
</code></pre></div>
<p>当实例x去调用相应的foo时，它实际上是</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">x.Inner</span><span class="o">)</span> <span class="k">=</span> <span class="kc">null</span>
</code></pre></div>
<p>所以才会出现下面的情况:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Null</span> <span class="o">=</span> <span class="kc">null</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">foo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">11</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">y.Inner</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">x.Inner</span>
              <span class="n">x</span><span class="o">.</span><span class="n">foo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
                      <span class="o">^</span>
</code></pre></div>
<h3>类型投影</h3>

<p>它相对于路径依赖类型减少了一些限制，并不依赖类的实例。针对上例就是，路径依赖类型Outer#Inner，它指代的类型是任何Outer实例中的任何Inner类型</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">bar</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Null</span> <span class="o">=</span> <span class="kc">null</span>
</code></pre></div>
<p>实际上，类型依赖的类型都可以使用类型投影来代替， 如下例。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">String</span> <span class="o">}</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">Foo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">foo</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Foo</span>
<span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span> <span class="o">=</span> <span class="nc">Foo</span><span class="k">@</span><span class="mf">182d</span><span class="n">ecdb</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">foo.</span><span class="k">type#</span><span class="kt">T</span> <span class="kt">=:=</span> <span class="kt">foo.T</span><span class="o">]</span>
<span class="n">res1</span><span class="k">:</span> <span class="o">=:=[</span><span class="kt">foo.T</span>,<span class="kt">foo.T</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div>
<p>实际上类型<code>=:=[foo.type#T, foo.T]</code>对应的是一个带类型参数的类。 所以，implicitly实际上触发了一次<strong>显示的隐式转换的查找</strong>(
在所有可能的范围内，能否找到一个<code>=:=[foo.type#T, foo.T]</code>类的隐式实例)。</p>

<p>由于<code>scala.Prefef</code>中已经在<code>=:=</code>的伴生对象中定义了一个隐式转换， 如下代码:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">implicitNotFound</span><span class="o">(</span><span class="n">msg</span> <span class="k">=</span> <span class="s">"Cannot prove that ${FROM} =:= ${TO}"</span><span class="o">)</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">=:=</span><span class="o">[</span><span class="kt">From</span>, <span class="kt">To</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">From</span> <span class="k">=&gt;</span> <span class="nc">To</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Serializable</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">final</span> <span class="k">val</span> <span class="n">singleton_=:=</span> <span class="k">=</span> <span class="k">new</span> <span class="o">=:=[</span><span class="kt">Any</span>,<span class="kt">Any</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="k">object</span> <span class="nc">=:=</span> <span class="o">{</span>
 <span class="c1">// implicit def tpEquals[A]: =:=[A, A] = singleton_=:=.asInstanceOf[A =:= A]
</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">tpEquals</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=:=</span> <span class="n">A</span> <span class="k">=</span> <span class="n">singleton_=:=</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div>
<p>显然只有在中置操作符前后的两个类型一致，<code>singleton_=:=.asInstanceOf[A =:= A]</code>， 这部分才能通过，则隐式转换才能被成功锁定，也间接的证明两个类型相等。</p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/scala/path-dependent-type/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/scala/lazy-variable/" rel="prev">&laquo;&nbsp;Scala基础之懒加载变量</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/cache/memcache/cluster/" rel="next">基于Memcached Java客户端Xmemcached的一致性哈希研究&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="f94b41f03d3fedce821eaa2fd106853e" data-title="Scala基础之路径依赖类型以及类型投影" data-url="/scala/path-dependent-type/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>