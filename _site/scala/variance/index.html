<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Scala基础之类型变化(variance)</title>
    <meta name="description" content="本文研究了Scala类型变化(variance)，协变(covariance)和反协变(contravariance)以及Variance Annotation的规则以及原因" />
    <meta name="keywords" content="类型变化，不可变，协变，反协变，Variance Annotation" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Scala基础之类型变化(variance)
</p>

<h1 class="lotus-pagetit">Scala基础之类型变化(variance)</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-03-13">2015-03-13</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>在刚接触Scala的时候，偶尔进入到Function1的源码，发现如下定义:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-T1</span>, <span class="kt">+R</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AnyRef</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span> <span class="o">}</span>
</code></pre></div>
<p>针对接受一个参数然后有返回值的函数，它的参数类型是-T1， 而返回值却是+R， 最开始的时候其实不太明白这种定义的含义。随着不断的学习，对于Scala的类型变化(Variance)有了更深的理解，遂写下这篇博客以总结相关的知识点。</p>

<h1>问题</h1>

<p>类型变化有哪几种？每一种分别有什么特点？Variance position的规则是怎样的？</p>

<h1>解决</h1>

<blockquote>
<p>Variance defines inheritance relationships of parameterized types</p>
</blockquote>

<p>Scala中的类型变化(type variance)定义了<b style="color:red">带参数类型</b>之间的&quot;继承&quot;关系(比如说Set[String]是Set[AnyRef]的子类)。<b style="red">注意是带参数类型，而不是类型参数的之间的</b>。结合Function1[-T, +R]，指的是Function1[-T, R]类型之间的关系，而不是指定T或R之间的关系。</p>

<h3 style="text-indent: 25px;">类型变化</h3>

<p>它一共有三种形式，并且决定了这些带参数的类型能够被传入方法的规则：</p>

<p><1> 不可变类型(Invaraince) -- Array[T]</p>

<p>对于接受一个Array[String]类型的参数的方法来说，只能传入Array[String]。
因为Array[T]在T类型上是不可变的。</p>

<p><2> 协变类型(Covariance) -- List[+T]</p>

<p>它一般是在接受类型参数的类型是<b style="color:red">不可变</b>的时候使用的。比如说scala中的immutable List[+A]。对于一个需要List[Any]参数的方法来说，我们可以传递List[String]。
因为List[+T]在T类型上是协变的。</p>

<p>一般来说，你可以这样认为<b style="color:red">如果S &lt;: T, 那么Container[S] &lt;: Container[T]</b></p>

<p><3> 反协变类型(Cotravariance) -- Function1[-A, +B]</p>

<p>这种一般使用的比较少。不过可以简单的理解和第二类正好相反。一般来说，你可以这样认为<b style="color:red">如果S &lt;: T, 那么Container[S] &gt;: Container[T]</b></p>

<p>对于Scala带参数类型或者是Generic Types 的三种变化个人还有一种从英文单词字面意义理解的方法。三种类型变化还有一种说法是invariant subtyping, covariant subtyping, contravariant subtyping。</p>

<p>InVariance[T] -- 就是InVariance的类型变化不会受T的类型变化的影响，即使T1 &lt;: T2。也不存在InVariance[T1] &lt;: InVariance[T2]。</p>

<p>CoVariance[T] -- Co在英文词根中是共同的，一起的意思。也就是CoVariance的类型变化会随着T的类型变化一起变化，即如果T1 &lt;: T2，那么CoVariance[T1] &lt;: CoVariance[T2]。</p>

<p>CotraVariance[T] -- Co在英文词根中是相反的，反对的意思。也就是CotraVariance的类型变化会随着T的类型变化而向相反的方向变化，即如果T1 &lt;: T2，那么CotraVariance[T1] &lt;: CotraVariance[T2]，也就说subtyping的方向被改变。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">GrandParent</span>
<span class="k">class</span> <span class="nc">Parent</span> <span class="k">extends</span> <span class="nc">GrandParent</span>
<span class="k">class</span> <span class="nc">Child</span> <span class="k">extends</span> <span class="nc">Parent</span>

<span class="k">class</span> <span class="nc">InVariance</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{}</span>
<span class="k">class</span> <span class="nc">CoVariance</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{}</span>
<span class="k">class</span> <span class="nc">ContraVariance</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{}</span>

<span class="k">object</span> <span class="nc">ContraVarianceTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">inCovariantMethod</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">InVariance</span><span class="o">[</span><span class="kt">Parent</span><span class="o">])</span> <span class="k">=</span> <span class="o">{}</span>
    <span class="k">def</span> <span class="n">coVariantMethod</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">CoVariance</span><span class="o">[</span><span class="kt">Parent</span><span class="o">])</span> <span class="k">=</span> <span class="o">{}</span>
    <span class="k">def</span> <span class="n">contraVariantMethod</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">ContraVariance</span><span class="o">[</span><span class="kt">Parent</span><span class="o">])</span> <span class="k">=</span> <span class="o">{}</span>

    <span class="k">val</span> <span class="n">invariantChild</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">InVariance</span><span class="o">[</span><span class="kt">Child</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">invariantParent</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">InVariance</span><span class="o">[</span><span class="kt">Parent</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">invariantGrandParent</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">InVariance</span><span class="o">[</span><span class="kt">GrandParent</span><span class="o">]</span>

    <span class="k">val</span> <span class="n">covariantChild</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CoVariance</span><span class="o">[</span><span class="kt">Child</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">covariantParent</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CoVariance</span><span class="o">[</span><span class="kt">Parent</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">covariantGrandParent</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CoVariance</span><span class="o">[</span><span class="kt">GrandParent</span><span class="o">]</span>

    <span class="k">val</span> <span class="n">contraVariantChild</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ContraVariance</span><span class="o">[</span><span class="kt">Child</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">contraVariantParent</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ContraVariance</span><span class="o">[</span><span class="kt">Parent</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">contraVariantGrandParent</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ContraVariance</span><span class="o">[</span><span class="kt">GrandParent</span><span class="o">]</span>

    <span class="cm">/*
     由于InVaraince在T类型上是不可变的，所以inCovariantMethod只能
     接受InVaraince[T]类型的参数
    */</span>
    <span class="n">inCovariantMethod</span><span class="o">(</span><span class="n">invariantChild</span><span class="o">)</span> <span class="c1">// 编译不通过
</span>    <span class="n">inCovariantMethod</span><span class="o">(</span><span class="n">invariantParent</span><span class="o">)</span> <span class="c1">// 编译通过
</span>    <span class="n">inCovariantMethod</span><span class="o">(</span><span class="n">invariantGrandParent</span><span class="o">)</span> <span class="c1">// 编译不通过
</span>
    <span class="cm">/*
     if S &lt;: T，CoVariance[S] &lt;: CoVariance[T]
     对于coVariantMethod，它只能接受CoVariance[Parent]或者是
     _ &lt;: CoVariance[Parent]
    */</span>
    <span class="n">coVariantMethod</span><span class="o">(</span><span class="n">covariantChild</span><span class="o">)</span> <span class="c1">// 编译通过
</span>    <span class="n">coVariantMethod</span><span class="o">(</span><span class="n">covariantParent</span><span class="o">)</span> <span class="c1">// 编译通过
</span>    <span class="n">coVariantMethod</span><span class="o">(</span><span class="n">covariantGrandParent</span><span class="o">)</span> <span class="c1">// 编译不通过
</span>
    <span class="cm">/*
     if S &lt;: T，CoVariance[S] &gt;: CoVariance[T]
     对于contraVariantMethod，它只能接受CoVariance[Parent]或者是
     _ &gt;: CoVariance[Parent]
    */</span>
    <span class="n">contraVariantMethod</span><span class="o">(</span><span class="n">contraVariantChild</span><span class="o">)</span> <span class="c1">// 编译不通过
</span>    <span class="n">contraVariantMethod</span><span class="o">(</span><span class="n">contraVariantParent</span><span class="o">)</span> <span class="c1">// 编译通过
</span>    <span class="n">contraVariantMethod</span><span class="o">(</span><span class="n">contraVariantGrandParent</span><span class="o">)</span> <span class="c1">// 编译通过
</span><span class="o">}</span>
</code></pre></div>
<p><strong>几点说明</strong></p>

<p><1> 针对上面的InVariance，CoVariance，ContraVariance，它们是三个类同时也是类型构造器。以InVariance为例，InVariance[Parent], InVariance[Child], InVariance[GrandParent]都是InVariance这个类型构造器构造出来的类型。</p>

<p><2> InVaraince可以被称为泛型类，它们构造出来的类型被称为<b style="color:red">带参数的类型</b>。</p>

<h3 style="text-indent: 25px;">反协变(Contravariance)</h3>

<p>虽然反协变在Scala中使用比较少，但是在有些地方还是很有必要的。
比如说，在Scala的Function1,... Fuction19中，它们在参数类型T都-T的。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">OutputChannel</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">o1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">OutputChannel</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">o2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">OutputChannel</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">ownTunnel</span><span class="o">(</span><span class="n">out</span><span class="k">:</span> <span class="kt">OutputChannel</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
</code></pre></div>
<p>针对OutputChannel，它定义了-T类型。针对任何需要OutputChannel[String]的地方，我们都可以传入OutputChannel[AnyRef]。OutputChannel[String]只能针对String
进行操作，而OutputChannel[AnyRef]不仅仅能对于String操作还能对其它类型进行操作。</p>

<p>其实这里面还有一个类型设计的原则: <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">里氏代换原则</a>。</p>

<blockquote>
<p>if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).</p>

<p>如果S是T的子类，那么T类型的实例可以在任何地方替换掉需要S实例的地方而不影响程序的正常运行。</p>
</blockquote>

<p>关于上面这段话还有一个结论同样适用，就是如果S能够支持所有T的操作并且<b style="color:red">要求的更少</b>(类型要求没有那么严格，AnyRef之于String)并且同样的方法，S能够提供<b style="color:red">更多的操作</b>，那么S就是T的子类。</p>

<p>OutputChannelAnyRef]是OutputChannel[String]的子类，因为它们支持同样的操作。并且同样的操作前者要求更低，因为它要求的类型是AnyRef，而后者要求的是String。显然前者要求没有后者严格。另外OutputChannelAnyRef]不仅仅能够对String操作，还可以对于其它AnyRef的子类进行操作。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">variantFunc</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Parent</span> <span class="o">=&gt;</span> <span class="nc">Parent</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>

<span class="k">val</span> <span class="n">pp</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Parent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Parent</span> 
<span class="cm">/* 
    val  pp = new Function1[Parent, Parent] {
        def apply(p: Parent) = new Parent 
    }
*/</span>
<span class="k">val</span> <span class="n">gp</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">GrandParent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Parent</span> <span class="c1">// Function1[GrandParent, Parent]
</span><span class="k">val</span> <span class="n">gc</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">GrandParent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Child</span> <span class="c1">// Function1[GrandParent, Child]
</span>
<span class="n">variantFunc</span><span class="o">(</span><span class="n">pp</span><span class="o">)</span>
<span class="n">variantFunc</span><span class="o">(</span><span class="n">gp</span><span class="o">)</span>
<span class="n">variantFunc</span><span class="o">(</span><span class="n">gc</span><span class="o">)</span>
</code></pre></div>
<p>由于Function1的参数是-T的，返回值是+T的。
Funtion1[GrandParent, Parent]可以被当做Funtion1[Parent, Parent]子类, 所以上述编译通过，原理可以参照上面的里氏代换原则。</p>

<h3 style="text-indent: 25px;">Variance Annotation</h3>

<h4 style="text-indent: 35px;">Type Parameters</h4>

<p>简单来说就是类型参数T前面的+, -。在说明这个问题之前先对于scala的Type Parameters(SLS 4.4)说明一下。</p>

<p><1> 类型参数可以在出现类型，类和函数定义中</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">List</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">WordDictionary</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">foldLeft</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">{}</span>
</code></pre></div>
<p><2> 类型参数可以是自己定界中的一部分，也可以成为同一定义中其它类型参数的上界或者下界</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">TS</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">C</span> <span class="k">&gt;:</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span><span class="o">]</span> <span class="c1">// A可以出现自己的定界中 A &lt;: B，也可以作为C的下界
</span></code></pre></div>
<p><3> 高阶类型参数(外层还有类型参数如 T[M], M就属于这种类型的)只在T的定义内部可见。他们的名字和其它在当前作用域可见的类型参数名字要不一样。另外，它们可以使用_表示。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">TS</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">]</span>, <span class="kt">M</span><span class="o">[</span><span class="kt">C</span><span class="o">]]</span> <span class="c1">// C只在M的定义中可见，而在T中不可见的
</span><span class="k">class</span> <span class="nc">TS</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]]</span> <span class="c1">// 编译不通过，因为A已经出现过
</span><span class="k">class</span> <span class="nc">TS</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span>

<span class="c1">// 更多合法的类型参数定义
</span><span class="o">[</span><span class="kt">Ex</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span>
<span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Comparable</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>, <span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">]</span>
<span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span>, <span class="kt">C</span> <span class="k">&gt;:</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span><span class="o">]</span>
<span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>, <span class="kt">N</span><span class="o">[</span><span class="kt">X</span><span class="o">]]</span>
<span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="kt">+X</span><span class="o">]</span> <span class="k">&lt;:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">X</span><span class="o">]]</span>

<span class="c1">// 典型的错误定义
</span><span class="o">[</span><span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span> <span class="c1">// 自己作为自己的界
</span><span class="o">[</span><span class="kt">A</span><span class="k">&lt;:</span><span class="kt">B</span>,<span class="kt">B</span><span class="k">&lt;:</span><span class="kt">C</span>,<span class="kt">C</span><span class="k">&lt;:</span><span class="kt">A</span><span class="o">]</span> <span class="c1">// 可以形象的理解为死循环了C是A的上界，后来又变成了A的下界
</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span> <span class="k">&gt;:</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span><span class="o">]</span> <span class="c1">// A是C的下界，B是C的上界。从而可以推出B是A的上界，但是并没有出现在定义中。
</span></code></pre></div>
<h4 style="text-indent: 35px;">Check Variance Annotation</h4>

<p>回到Variance Annotation(以下简称VP)的问题，Scala对于类型参数的VP是有严格要求的。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">MockType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">M</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">D</span>
    <span class="k">var</span> <span class="n">fst</span><span class="k">:</span> <span class="kt">E</span>
<span class="o">}</span>
</code></pre></div>
<p>一般来说，方法参数的VP是-C，而方法返回值是+D，可变量类型的VP只能是T。而这种情况仅仅是针对没有复杂嵌套的情况，如果方法中套方法，情况又不一样了。
下面的探讨都是基于+T与-T的。对于T，它可以出现在任何位置所以不属于本次讨论的范围。</p>

<p>在Programming In Scala的Type Parameterization，19.4 Checking variance annotations最后作者留下了一个故意构造的复杂类型。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Cat</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">meow</span><span class="o">[</span><span class="kt">W^-</span><span class="o">](</span><span class="n">volume</span><span class="k">:</span> <span class="kt">T^-</span><span class="o">,</span> <span class="n">listener</span><span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]^-)</span>
      <span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]</span><span class="kt">^-</span>, <span class="kt">U^+</span><span class="o">]^+</span>
<span class="o">}</span>
</code></pre></div>
<p>下面结合这个例子来说明VP的问题。另外在研究Variance的这段时间，我发现很多观点都只知道是这样但是找不到为什么(比如说 函数的参数类型位置只能出现-T类型的)。后来参考一篇博客的思路，发现使用<b style="color:red">反推法</b>会使整个理解更轻松一点。</p>

<p><1> 方法的返回值的VP只能是+T</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// Valid Definition
</span><span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
 <span class="k">def</span> <span class="n">ts</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"valid"</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">pa</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">child</span> <span class="c1">//相当于Java中的UpCast
</span><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">ts</span>

<span class="c1">// Invalid Definition
</span><span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mi">123</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">pa</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">child</span>
<span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">ts</span> 
<span class="c1">// 如果方法返回值的VP是-T的，相当于把Integer类型赋值给了String，会导致错误
</span></code></pre></div>
<p><2> 方法参数的VP只能是-T，另外对于被嵌套的方法，这条规则是不适用的(个人猜测Scala
VP的约束只对于top level的方法参数有约束)。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// Valid Definition
</span><span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="s">"valid"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">pa</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">child</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">ts</span><span class="o">(</span><span class="s">"valid"</span><span class="o">)</span>

<span class="c1">// Invalid Definition
</span><span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="s">"invalid"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">pa</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">child</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">ts</span><span class="o">(</span><span class="mi">123</span><span class="o">)</span> 
<span class="c1">// 如果方法参数的VP可以是+T, 就会出现Integer类型的传递给了String类型，会导致错误
</span>
<span class="c1">// Nesting Method
</span><span class="k">class</span> <span class="nc">NestingVar</span><span class="o">[</span><span class="kt">+A</span>, <span class="kt">-C</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">get1</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><3> 可变量类型的VP只能是T，但是实例私有或受保护的变量不受这条规则影响。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">ts</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">ts</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="mi">123</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">pa</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">child</span>
<span class="n">pa</span><span class="o">.</span><span class="n">ts</span> <span class="k">=</span> <span class="s">"invalid"</span> <span class="c1">// 编译出错 String强制转换成Any
</span>
<span class="k">class</span> <span class="nc">PrivateVar</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">ts2</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="c1">// 编译通过
</span><span class="o">}</span>
</code></pre></div>
<p>另外在Scala中，var ts: A在编译之后会转换成Get方法A ts()，Set方法 ts_=(x: A)。可以理解为，A要能同时出现在方法返回值和方法参数的位置。显然T类型是唯一选择。</p>

<p><4> 下界类型的VP和它构造的类型参数的VP是相反的，上界则没有这种情况。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/*
      类型参数B的VP是-B的，下界导致它所在的位置的VP发生反转即可以接受+A类型
  */</span>
  <span class="k">def</span> <span class="n">ts1</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="c1">// successful compilation
</span>
 <span class="k">def</span> <span class="n">ts2</span><span class="o">[</span><span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> 
 <span class="c1">// Error: covariant type A occurs in contravariant position in type &lt;: A of type B
</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
 <span class="k">def</span> <span class="n">ts3</span><span class="o">[</span><span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="c1">// successful compilation
</span>
 <span class="k">def</span> <span class="n">ts4</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
 <span class="c1">// Error: contravariant type A occurs in covariant position in type &gt;: A of type B
</span><span class="o">}</span>
</code></pre></div>
<p>为什么下界会导致类型参数的VP反转呢？</p>

<p>&amp; 方法参数处理能力的方向变化</p>

<p>&amp; 从协变的角度来说也是说得通的</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">GP</span>
<span class="k">class</span> <span class="nc">P</span> <span class="k">extends</span> <span class="nc">GP</span>
<span class="k">class</span> <span class="nc">C</span> <span class="k">extends</span> <span class="n">P</span>

<span class="cm">/*
   下例中，方法类型参数声明了方法只能传入C的父类再加上底下的upcast。
   &lt;1&gt; 默认情况下，ts1只能接受B类型的参数以及它的子类。但是通过B &gt;: C, 
   它可以接受B类型的父类。VP的反转实际上就是subtyping的反转，
   比如说原来只能处理本身以及子类，后来变成了本身和父类。
   &lt;2&gt; 下面的案例使用了前面提到的反推法。由于协变的存在，
   所以下面那一步upcast是合理的。那么理所当然parent.ts1[GP](GP 实例)，
   如果没有B &gt;: C的存在，那么将GP实例(父类实例)传入一个要求它自身以及子类实例的方法，
   肯定会有错误。
*/</span>
<span class="k">object</span> <span class="nc">MethodParamVariance</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">ts1</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">C</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">println</span><span class="o">(</span><span class="s">"lower bound result in vp flip"</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">parent</span><span class="k">:</span> <span class="kt">Container</span><span class="o">[</span><span class="kt">GP</span><span class="o">]</span> <span class="k">=</span> <span class="n">child</span> <span class="c1">// upcast
</span>    <span class="n">parent</span><span class="o">.</span><span class="n">ts1</span><span class="o">(</span><span class="k">new</span> <span class="nc">GP</span><span class="o">)</span> 
    <span class="n">parent</span><span class="o">.</span><span class="n">ts1</span><span class="o">[</span><span class="kt">Any</span><span class="o">](</span><span class="k">new</span> <span class="nc">GP</span><span class="o">)</span> <span class="c1">//和上面那种调用是等价的
</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">Container</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">ts1</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p><5> 对于S[..T..]的类型参数，如果S[..T..]的VP是T的话，那么T的VP也是T。如果S[..T..]的VP是-T的话，那么T的类型就是和S[...T..]的VP相反。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">PrivateVar</span><span class="o">[</span><span class="kt">+A</span>, <span class="kt">+C</span>, <span class="kt">B</span><span class="o">[</span><span class="kt">C</span><span class="o">]](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">protected</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">ts2</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span>

 <span class="cm">/*
  Error covariant type C occurs in invariant position 
  in type =&gt; B[C] of method ts3
  因为B[C]的VP是T，所以C的位置也是T
 */</span>
 <span class="k">var</span> <span class="n">ts3</span><span class="k">:</span> <span class="kt">B</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> 
<span class="o">}</span>

<span class="cm">/*
 方法的返回值类型 PrivateVar[A, PrivateVar[C, A]]的第
 二个类型参数PrivateVar[C, A]的VP是-T，所以里面的每一个类型参数的VP都与它相反。
 PrivateVar的第一个类型参数由+T变成了-T，所以可以传入C，
 PrivateVar的第二个类型参数由-T变成了+T，所以可以传入A。
*/</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">PrivateVar</span><span class="o">[</span><span class="kt">+A</span>, <span class="kt">-C</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">m</span><span class="k">:</span> <span class="kt">PrivateVar</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">PrivateVar</span><span class="o">[</span><span class="kt">C</span>, <span class="kt">A</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div>
<p>由于关于scala variance position的情况和内容太多，本文就暂时讨论这里。以上的规则应该足够帮助我们理解上面那只猫的类型了。</p>

<h1>结语</h1>

<p>这次研究Scala的Variance还是花了不少功夫的，最后参考列出的链接足以证明。特别是在参阅Scala Reference的时候，发现对于Scala的语法还有很多需要加深理解的。当然，对于Scala Variance的这次梳理对于我以后在项目中的使用肯定还是有一定的帮助，以后对于这个概念理解更深以后，也会再次更新这篇博客。</p>

<p>针对本文提到的观点，如有异议，欢迎指正和交流。</p>

<h1>参考</h1>

<p><1> <a href="http://www.sala-notes.org/2011/04/specializing-for-primitive-types/">@specialized</a></p>

<p><2> Scala CookBook Chapter 19</p>

<p><3> Programming In Scala Second Edition Chapter 19</p>

<p><4> Scala Language Reference Chapter 4</p>

<p><5> Variance Position指的是在某个类型参数可以出现的地方，它应该是+T, -T还是T</p>

<p><6> <a href="http://blogs.atlassian.com/2013/01/covariance-and-contravariance-in-scala/">covariance-and-contravariance-in-scala</a></p>

<p><7> <a href="http://stackoverflow.com/questions/23427270/how-to-understand-the-variance-position-of-a-method-parameter-is-the-opposite-o">how-to-understand-the-variance-position-of-a-method-parameter-is-the-opposite-o</a></p>

<p><8> <a href="http://stackoverflow.com/questions/23958349/why-do-lower-type-bounds-change-the-variance-position">why-do-lower-type-bounds-change-the-variance-position</a></p>

<p><9> <a href="http://stackoverflow.com/questions/12451702/variance-annotation-keeping-track-positive-and-negative-positions-by-scala?rq=1">variance-annotation-keeping-track-positive-and-negative-positions-by-scala</a></p>

<p><10> <a href="http://ju.outofmemory.cn/entry/72832">Scala类型系统</a></p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/scala/variance/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/mongodb/array-update/" rel="prev">&laquo;&nbsp;MongoDB基础之数组类型元素的基本操作</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/scala/quote/" rel="next">Scala基础之三引号(""")&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="c79dbc3f72c0daff6f075ab38d7e3738" data-title="Scala基础之类型变化(variance)" data-url="/scala/variance/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>