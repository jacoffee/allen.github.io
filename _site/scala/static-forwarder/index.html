<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Scala基础之静态代理(static forwarder)</title>
    <meta name="description" content="本文研究了静态代理的概念，产生方式以及Scala编译器对于静态代理的一些处理机制" />
    <meta name="keywords" content="静态代理,单例对象" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Scala基础之静态代理(static forwarder)
</p>

<h1 class="lotus-pagetit">Scala基础之静态代理(static forwarder)</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-02-06">2015-02-06</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>在Scala类中我们并没有像Java那样显示的声明main方法，而是通过继承Trait App来实现的。今天在写下面这段代码的时候突然报了如下错误:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">  <span class="c1">// Reason: companion is a trait, which means no static forwarder can be generated.
</span>  <span class="k">trait</span> <span class="nc">TryCatch</span> <span class="o">{}</span>
  <span class="k">object</span> <span class="nc">TryCatch</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{}</span>
</code></pre></div>
<p>提示说的很清楚TryCatch的伴生&quot;类&quot;是一个特质，这样的话静态代理就无法生成了。</p>

<h2>问题</h2>

<p>那么Scala中的静态代理是什么呢？为什么Trait中无法生成静态代理呢？</p>

<h2>解决</h2>

<p>Static forwarder provides easy way for java to invoke scala object&#39;s method(静态代理让Java调用Scala的方法更方便了)。</p>

<p>首先，我们采用一个简单的例子来查看什么是static forwarder。</p>

<p>eg:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">Forwarder</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">foo</span> <span class="k">=</span> <span class="mi">2</span>
<span class="o">}</span>
</code></pre></div>
<p>翻译之后会生成两个类Forwarder.class, Forwarder$.class。</p>

<p><b style="color: red">反编译出来Forwarder.class</b></p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Forwarder</span>
<span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">foo</span><span class="o">()</span>
  <span class="o">{</span>
    <span class="k">return</span> <span class="n">Forwarder</span><span class="o">..</span><span class="na">MODULE</span><span class="err">$</span><span class="o">.</span><span class="na">foo</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><b style="color:red">Scala编译器生成的<strong>合成类</strong>(synthetic class) Forwarder$.class</b></p>
<div class="highlight"><pre><code class="language-Java" data-lang="Java">public final class Forwarder$
{
    public static final MODULE$;

    static
    {
     new ();
    }

    public int foo()
    {
     return 2; 
    } 
    private Forwarder$() { MODULE$ = this; }
}
</code></pre></div>
<p>我们可以看出，Forwarder中foo方法实际上引用的是Forwarder中静态实例MODULE$(通过static块，静态初始化生成的)的foo方法。</p>

<blockquote>
<p><b style="color:red">这实际上Scala编译器的一个规则，如果你定义了一个单例对象object A但是并没有一个同名的class A, 那么编译器就会为你生成一个同名的class A并且在里面定义所有object A中方法的静态代理。</b>
 如果你已经有了一个同名的class A，这时编译器便不会再生成静态代理。此时Java代码可以通过MODULE$属性来访问单例对象。</p>
</blockquote>

<p><strong>上面两条规则有一个特别需要注意的地方，什么叫已经有了一个同名的class A</strong>。
经过验证发现这里的含义是如果你先在Desktop文件下通过</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">  <span class="k">class</span> <span class="nc">Test</span> <span class="o">{}</span>
</code></pre></div>
<p>编译出Test.class，然后通过</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">  <span class="k">object</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">foo</span> <span class="k">=</span> <span class="mi">2</span>
  <span class="o">}</span>
</code></pre></div>
<p>编译出Test$.class, <strong>由于在相同的文件夹下已经有一个Test.class</strong>, 所以此时Test.class 并没有像之前那样出现静态代理method。</p>

<p>但是如果你在同一个文件中写下如下代码：</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">  <span class="k">object</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">foo</span> <span class="k">=</span> <span class="mi">2</span>
  <span class="o">}</span>
  <span class="k">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">myMethod</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div>
<p><strong>此时在Test.class中会生成相应的静态代理类</strong>, 通过打印jvm的log也可以看出</p>
<div class="highlight"><pre><code class="language-" data-lang="">$ scalac -Ylog:jvm Test.scala 
[log jvm] No mirror class for module with linked class: Test
[log jvm] missingHook(package &lt;root&gt;, android): &lt;none&gt;
[log jvm] Adding static forwarders from 'class Test' to implementations in 'object Test'
</code></pre></div>
<p>我们通过Java代码来测试一下静态代理</p>
<div class="highlight"><pre><code class="language-Java" data-lang="Java">public class MainTest {
    public static void main(String[] args) {
        int r = Forwarder$.MODULE$.foo(); 
        int r1 = Forwarder.foo();
      // 如果使用第一种方法调用foo，我们就需要了解Forwarder$.class的bytecode,
      // 这样不友好。所以Scala编译器在Forwarder.class中提供了
      // 单例对象方法的"副本"即foo以实现静态代理机制。
        System.out.println(r == r1); // true
    }
}
</code></pre></div>
<p>为了进一步理解这个概念，引用来自Programming In Scala中的一句话。</p>

<blockquote>
<p>Java has no exact equivalent to a singleton object, but it does have static methods.
The Scala translation of singleton objects uses a combination of static and instance methods. For every Scala singleton object, the compiler will <b style="color:red">create a Java class for the object with a dollar sign added to the end.</b></p>

<p>For a singleton object named App, the compiler produces a Java class named App$.
This class has all the methods and fields of the Scala singleton object.
The Java class also has a single static field named MODULE$ to hold the one instance of the class that is created at run time.</p>
</blockquote>

<p>上面那段话很好的解释了Forwarder$出现的原因并且在Forwarder$中有一个静态的实例MODULE$以及Scala单例对象Forwarder的所有实例方法。</p>

<h2>结语</h2>

<p>最后来回答开篇的问题:</p>

<p><1> 静态代理实际上就是MODULE$。</p>

<p><2> 因为trait TryCatch(编译之后实际上变成了public abstract interface TryCatch)中无法生成
单例对象的静态代理，interface中显然不能出现静态方法(它是类层面的概念)。</p>

<h2>参考</h2>

<p>&gt; <a href="http://hongjiang.info/scala-static-forwarders/">Scala里的静态代理(static-forwarders)</a></p>

<p>&gt; <a href="http://stackoverflow.com/questions/5721046/singletons-as-synthetic-classes-in-scala">Singletons as Synthetic classes in Scala?</a></p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/scala/static-forwarder/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/scala/try-catch/" rel="prev">&laquo;&nbsp;Scala基础之try...catch...finally</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/scala/implicits/" rel="next">Scala基础之隐式转换(implicit-conversion)&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="ae1c4aa3fc3d7ec318c814a4093d0e29" data-title="Scala基础之静态代理(static forwarder)" data-url="/scala/static-forwarder/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>