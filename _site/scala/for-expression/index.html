<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Scala基础之For表达式</title>
    <meta name="description" content="本文研究了Scala For表达式以及背后涉及的语法糖" />
    <meta name="keywords" content="For表达式，语法糖，高阶函数" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Scala基础之For表达式
</p>

<h1 class="lotus-pagetit">Scala基础之For表达式</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-02-15">2015-02-15</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>最开始学习Scala的时候，公司的人告诫我不要轻易使用For表达式，因为&quot;有点像&quot;Java中命令式的编程与函数式编程的基因有点格格不入(<b style="color:red">尽管Scala是个面对对象和函数式编程的混血儿，但是在日常开发中它的函数式编程特点还是占据了主导地位</b>)。</p>

<p>后来随着学习的深入，发现在有些场景。For表达式是比map, flatMap的嵌套是更加优雅的。实际上，背后也只是map, flatMap, withFilter等高阶函数的组合调用。</p>

<h1>问题</h1>

<p>Scala For的基本语法以及背后涉及的语法糖问题？</p>

<h1>解决</h1>

<h3 style="text-indent: 25px;">基本格式: for ( seq ) yield expr</h3>

<blockquote>
<p>seq is a sequence of generators, definitions, and filters, with semi- colons between successive elements.
seq就是一系列生成器，定义以及过滤的组合，并且以；分隔。</p>
</blockquote>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">People</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">isMale</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">children</span><span class="k">:</span> <span class="kt">People*</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">SugarFor</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">lara</span> <span class="k">=</span> <span class="nc">People</span><span class="o">(</span><span class="s">"Lara"</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">bob</span> <span class="k">=</span> <span class="nc">People</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">julie</span> <span class="k">=</span> <span class="nc">People</span><span class="o">(</span><span class="s">"Julie"</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">,</span> <span class="n">julie</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">certainName</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
        <span class="n">p</span> <span class="k">&lt;-</span> <span class="n">people</span> <span class="c1">// generator
</span>        <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="c1">// definition
</span>        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">"Bob"</span><span class="o">)</span> 
        <span class="c1">// filter also called guard
</span>    <span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
<span class="o">}</span>
</code></pre></div>
<p>For表达式其实是一种<b style="color:red">语法糖</b>。规则如下:</p>

<p>一般来说，For表达式都会被编译器转换成一些高阶函数的调用(map, flatMap, withFilter)。如果For表达式中没有<b style="color:red">yield</b>的话，那么它会被转换成withFilter和foreach组合调用。前者不一定有，但是后者一定有。</p>

<p>上面的代码的class文件反编译出来的结果：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="cm">/* 
 上面的三种类型分别对应了map, withFilter, map
 不过需要注意的是上面的filter实际上在defnition前面执行的，
 如果去掉yield的话，最后一步就会变成foreach。
*/</span>

 <span class="k">this</span><span class="o">.</span><span class="n">$outer</span><span class="o">.</span><span class="na">certainName_</span><span class="n">$eq</span><span class="o">(</span>
    <span class="o">(</span><span class="n">List</span><span class="o">)(</span>
    <span class="o">(</span><span class="n">TraversableLike</span><span class="o">)</span><span class="k">this</span><span class="o">.</span><span class="n">$outer</span><span class="o">.</span><span class="na">people</span><span class="o">().</span>
        <span class="n">map</span><span class="o">(</span>
          <span class="k">new</span> <span class="n">SugarFor</span><span class="o">..</span><span class="na">anonfun</span><span class="o">.</span><span class="mi">4</span><span class="o">(),</span>          
          <span class="n">List</span><span class="o">..</span><span class="na">MODULE</span><span class="err">$</span><span class="o">.</span><span class="na">canBuildFrom</span><span class="o">()</span>
        <span class="o">)</span>
    <span class="o">).</span><span class="na">withFilter</span><span class="o">(</span>
        <span class="k">new</span> <span class="n">SugarFor</span><span class="o">..</span><span class="na">anonfun</span><span class="o">.</span><span class="mi">5</span><span class="o">()</span>
    <span class="o">).</span><span class="na">map</span><span class="o">(</span>
        <span class="k">new</span> <span class="n">SugarFor</span><span class="o">..</span><span class="na">anonfun</span><span class="o">.</span><span class="mi">6</span><span class="o">(),</span>        
        <span class="n">List</span><span class="o">..</span><span class="na">MODULE</span><span class="err">$</span><span class="o">.</span><span class="na">canBuildFrom</span><span class="o">()</span>
    <span class="o">)</span>
<span class="o">);</span>
</code></pre></div>
<h3 style="text-indent: 25px;">重要规则展开</h3>

<p><1> 同时出现多个Generator以及过滤表达式的</p>

<p>对于这种情况，有一个简单的通用规则。当Generator表达式数目超过1时，每多一个就会多一个flatMap。总的flatMap个数总是比Generator数目少1。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">ForTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
    <span class="c1">// 两个generator
</span>    <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
        <span class="n">l1</span> <span class="k">&lt;-</span> <span class="n">list</span><span class="o">;</span>
        <span class="n">l2</span> <span class="k">&lt;-</span> <span class="n">list</span> <span class="k">if</span> <span class="n">l2</span> <span class="o">&gt;</span> <span class="mi">2</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
        <span class="o">(</span><span class="n">l1</span><span class="o">,</span> <span class="n">l2</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">x1</span> <span class="k">=&gt;</span>
        <span class="n">list</span><span class="o">.</span><span class="n">withFilter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">x2</span> <span class="k">=&gt;</span>
            <span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span><span class="o">)</span> <span class="c1">// true
</span><span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">ForTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">list</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
    <span class="c1">// 三个generator
</span>    <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
        <span class="n">l1</span> <span class="k">&lt;-</span> <span class="n">list</span><span class="o">;</span>
        <span class="n">l2</span> <span class="k">&lt;-</span> <span class="n">list</span> <span class="k">if</span> <span class="n">l2</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">l3</span> <span class="k">&lt;-</span> <span class="n">list</span> <span class="k">if</span> <span class="n">l3</span> <span class="o">&gt;</span> <span class="mi">2</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
        <span class="o">(</span><span class="n">l1</span><span class="o">,</span> <span class="n">l2</span><span class="o">,</span> <span class="n">l3</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">list</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">x1</span> <span class="k">=&gt;</span>
        <span class="n">list</span><span class="o">.</span><span class="n">withFilter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">x2</span> <span class="k">=&gt;</span>
            <span class="n">list</span><span class="o">.</span><span class="n">withFilter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">x3</span> <span class="k">=&gt;</span>
                <span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">,</span> <span class="n">x3</span><span class="o">)</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">assert</span><span class="o">(</span><span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span><span class="o">)</span> <span class="c1">// true
</span><span class="o">}</span>
</code></pre></div>
<p><2> 如果Generator过程中出现复杂的Pattern</p>

<p>一般情况下，Generator左边的表达式一般是单一变量x或者是tuple。但如果左边是一个比较复杂的Pattern，那么编译器会转换成如下格式:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala">    <span class="k">for</span> <span class="o">(</span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr2</span>

    <span class="c1">// 这样就确保只map通过withFilter的item
</span>    <span class="n">expr1</span> <span class="n">withFilter</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="kc">true</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}</span> <span class="n">map</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="n">expr2</span>
    <span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">net.liftweb.mongodb.JsonFormats</span>
<span class="k">object</span> <span class="nc">ForTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="k">with</span> <span class="nc">JsonFormats</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">jValueformate</span> <span class="k">=</span> <span class="n">allFormats</span>
    <span class="k">val</span> <span class="n">pet1</span> <span class="k">=</span> <span class="nc">Pet</span><span class="o">(</span><span class="s">"stella"</span><span class="o">,</span> <span class="mi">23</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">pet2</span> <span class="k">=</span> <span class="nc">Pet</span><span class="o">(</span><span class="s">"dodge"</span><span class="o">,</span> <span class="mi">12</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">petJValue</span> <span class="k">=</span> <span class="o">(</span><span class="n">pet1</span> <span class="o">::</span> <span class="n">pet2</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">Extraction</span><span class="o">.</span><span class="n">decompose</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
        <span class="nc">JObject</span><span class="o">(</span>
            <span class="nc">JField</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="nc">JString</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">::</span> 
            <span class="nc">JField</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="nc">JInt</span><span class="o">(</span><span class="n">age</span><span class="o">))</span> <span class="o">::</span> 
            <span class="nc">Nil</span>
        <span class="o">)</span> <span class="k">&lt;-</span> <span class="n">petJValue</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
        <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">.</span><span class="n">intValue</span><span class="o">)</span>
    <span class="o">}</span>


    <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">petJValue</span><span class="o">.</span><span class="n">withFilter</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">JObject</span><span class="o">(</span>
            <span class="nc">JField</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="nc">JString</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">::</span> 
            <span class="nc">JField</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="nc">JInt</span><span class="o">(</span><span class="n">age</span><span class="o">))</span> <span class="o">::</span> 
        <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}.</span><span class="n">map</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">JObject</span><span class="o">(</span>
            <span class="nc">JField</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="nc">JString</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">::</span> 
            <span class="nc">JField</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="nc">JInt</span><span class="o">(</span><span class="n">age</span><span class="o">))</span> <span class="o">::</span> 
        <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">.</span><span class="n">intValue</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="n">assert</span><span class="o">(</span><span class="n">r1</span> <span class="o">==</span> <span class="n">r2</span><span class="o">)</span> <span class="c1">// true
</span><span class="o">}</span>
</code></pre></div>
<p><3> 如果For表达式中出现了defition语句</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"> <span class="k">for</span> <span class="o">{</span> <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">;</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span> <span class="n">expr3</span> <span class="o">}</span>

 <span class="c1">// translate
</span>
 <span class="k">for</span> <span class="o">{</span> 
    <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">for</span><span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">expr2</span><span class="o">)};</span> <span class="n">seq</span>  <span class="o">}</span> <span class="k">yield</span> <span class="o">{</span> <span class="n">expr3</span> <span class="o">}</span>
</code></pre></div>
<p>这种情况下，x可能被计算两遍，因为expr2中可能会引用x。所以这种写法不是很提倡。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 注意下面代码的class反编译文件
</span>
<span class="k">object</span> <span class="nc">ForTest</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
        <span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
        <span class="n">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 很明显可以发现definition语句实际上对应了一次map。</span>
<span class="c1">// 第一次map仅仅只是生成了(x, expr2),   第二次map才是真正的获得最后结果的(x, y)</span>

  <span class="k">this</span><span class="o">.</span><span class="na">r1</span> <span class="o">=</span> 
      <span class="o">((</span><span class="n">IndexedSeq</span><span class="o">)(</span>
      <span class="o">(</span><span class="n">TraversableLike</span><span class="o">)</span><span class="n">RichInt</span><span class="o">..</span><span class="na">MODULE</span><span class="err">$</span>
<span class="o">.</span><span class="na">to</span><span class="n">$extension0</span><span class="o">(</span><span class="n">Predef</span><span class="o">..</span><span class="na">MODULE</span><span class="err">$</span><span class="o">.</span><span class="na">intWrapper</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="mi">5</span><span class="o">).</span><span class="na">map</span><span class="o">(</span>
<span class="k">new</span> <span class="nf">AbstractFunction1</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> 
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">.</span><span class="na">mcII</span><span class="o">.</span><span class="na">sp</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="o">,</span> <span class="n">IndexedSeq</span><span class="o">..</span><span class="na">MODULE</span><span class="err">$</span><span class="o">.</span><span class="na">canBuildFrom</span><span class="o">()</span>
<span class="o">)).</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="n">AbstractFunction1</span><span class="o">()</span> <span class="o">{</span> 
 <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">x</span><span class="err">$</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span> 
          <span class="n">Tuple2</span> <span class="n">localTuple2</span> <span class="o">=</span> <span class="n">x</span><span class="err">$</span><span class="mi">1</span><span class="o">;</span> 

          <span class="k">if</span> <span class="o">(</span><span class="n">localTuple2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">localTuple2</span><span class="o">.</span><span class="na">_1</span><span class="n">$mcI$sp</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">localTuple2</span><span class="o">.</span><span class="na">_2</span><span class="n">$mcI$sp</span><span class="o">();</span>
            <span class="n">Tuple2</span><span class="o">.</span><span class="na">mcII</span><span class="o">.</span><span class="na">sp</span> <span class="n">localsp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tuple2</span><span class="o">.</span><span class="na">mcII</span><span class="o">.</span><span class="na">sp</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

            <span class="k">return</span> <span class="n">localsp</span><span class="o">;</span> 
          <span class="o">}</span>

          <span class="k">throw</span> <span class="k">new</span> <span class="n">MatchError</span><span class="o">(</span><span class="n">localTuple2</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">,</span> <span class="n">IndexedSeq</span><span class="o">..</span><span class="na">MODULE</span><span class="err">$</span><span class="o">.</span><span class="na">canBuildFrom</span><span class="o">()));</span>
  <span class="o">}</span>
</code></pre></div>
<h3 style="text-indent: 25px;">通用的规则总结</h3>

<p>通过上面的例子，我们可以得出如下结论:</p>

<p><1> For表达式可以被转化成map, flatMap, withFilter等高阶函数的调用，反过来<b style="color:red">map, flatMap, filter也能够通过for来实现(因为withFilter并不是简单的filter所以，不能直接实现)</b></p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">HighOrderFuncViaFor</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> 
    <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">l</span>  <span class="k">&lt;-</span> <span class="n">list</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">f</span><span class="o">(</span><span class="n">l</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> 
    <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">l</span> <span class="k">&lt;-</span> <span class="n">list</span><span class="o">;</span><span class="n">l1</span> <span class="k">&lt;-</span> <span class="n">f</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">l1</span>

    <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">list</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> 
    <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span> <span class="n">l</span> <span class="k">&lt;-</span> <span class="n">list</span> <span class="k">if</span> <span class="n">f</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">l</span>
<span class="o">}</span>
</code></pre></div>
<p><2> 只要定义了map, flatMap, withFilter等高阶函数的数据结构都可以进行for表达式(排除没有yield的情况)。</p>

<p>具体的规则如下，针对给定的数据类型F：</p>

<p><1> 如果F只定义了map操作，那么对应的For只允许单个的Generator操作，因为前面提到过两个及以上的Generator就会涉及到flatMap。</p>

<p><2> 如果同时定义了map和flatMap，那么就能进行多个Generator的操作。</p>

<p><3> 如果定义了withFilter方法，那么就会支持以if开头的过滤表达式。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">ADT</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">ADT</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">ADT</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ADT</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>

    <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">ADT</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div>
<p>不过上面的withFilter的实现实际上是很废的，因为每次调用都会返回一个新的ADT[A]，相当于产生了中间状态。所以在Option中的实现避免了上面的情况。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">WithFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WithFilter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
</code></pre></div>
<p>WithFilter就像是&quot;记住&quot;了对于类型中元素的操作，等待map, flatMap的时候再进行操作，有点lazy的意思。</p>

<h1>结语</h1>

<p>For表达式说到底，其实不是什么新语法。只是map, flatMap, withFilter等高阶函数的语法糖。至于什么时候使用，完全取决于个人偏好和编程风格。</p>

<p>在实际的开发中，当多个Option和List混合在一起并且需要Guard的时候，那么For无疑是个不错的选择。这样可以避免map和flatMap的嵌套。</p>

<h1>参考</h1>

<p><1> Programming In Scala Second Edition Chapter 23</p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/scala/for-expression/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/scala/value-types/" rel="prev">&laquo;&nbsp;Scala基础之值类型(value types)</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/mongodb/array-update/" rel="next">MongoDB基础之数组类型元素的基本操作&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="708d91df9e7ec1dc30e4f6af8b57183f" data-title="Scala基础之For表达式" data-url="/scala/for-expression/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>