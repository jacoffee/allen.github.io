<!DOCTYPE html>
<html id="J-html" class="">
<head>
    <meta charset="UTF-8" />
    <meta name="generator" content="Jekyll" />
    <title>Scala基础之值类型(value types)</title>
    <meta name="description" content="本文研究了Scala值类型及基本的运用" />
    <meta name="keywords" content="值类型，类型投影，类型指示器，参数类型，元祖类型，带注解的类型，复合类型，中置类型，函数类型，存在类型" /><!-- For SEO-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="stylesheet" type="text/css" media="all" href="/static/css/style.css" />
    <!-- syntax highlighting CSS  need pygments support-->
    <link rel="stylesheet" href="/static/css/syntax.css" type="text/css" />
    <!-- use to display line number-->
    <!--<link rel="stylesheet" href="/static/css/line.css" type="text/css" />-->
    <!--[if lt IE 9]>
    <script src="/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
             
                 
                 
                 
                
            <li class="home ">
                <a href="/" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="/archives/" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
             
                 
                 
                 
                
            <li class="">
                <a href="https://github.com/jacoffee/jacoffee.github.io" rel="bookmark" title="博客源代码">
                    <i class="icon-github"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="/" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="/archives/" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    Scala基础之值类型(value types)
</p>

<h1 class="lotus-pagetit">Scala基础之值类型(value types)</h1>

<p class="lotus-meta">Published on <time class="date" pubdate="2015-02-13">2015-02-13</time></p>

<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>今天定义一个函数的时候，突然发现需要使用一个类型里面的成员，于是想到类型投影(type projection)。在查阅Scala Reference的时候，发现类型投影只是Scala值类型中的一种，于是决定将Scala值类型研究一下。</p>

<h1>问题</h1>

<p>Scala的值类型有哪几种，每一种如何去使用？</p>

<h1>解决</h1>

<p>首先我们需要明白的是，Scala中每一个值都是有类型的。</p>

<p><1> <strong>Singleton Types(单例类型)</strong></p>

<p>基本格式: p.type </p>

<p>说明: p必须是<b style="color:red">scala.AnyRef</b>的子类。这种通常用于返回自身类型，从而用于链式调用。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Abstract0</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
    <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">j</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">self.type</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Concrete0</span> <span class="k">extends</span> <span class="nc">Abstract0</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">j</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
        <span class="n">i</span> <span class="k">=</span> <span class="n">j</span>
        <span class="k">this</span>
    <span class="o">}</span>
    <span class="k">def</span> <span class="n">get</span> <span class="k">=</span> <span class="n">i</span>
<span class="o">}</span>

<span class="c1">// 调用(上面的例子有点low，但是能说明问题)
</span><span class="o">(</span><span class="k">new</span> <span class="nc">Concrete0</span><span class="o">).</span><span class="n">set</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="n">get</span>
</code></pre></div>
<p><2> <strong>Type Projection(类型投影)</strong></p>

<p>基本格式: T#X</p>

<p>说明: X必须是T的&quot;类型成员&quot;(我的理解是X必须是scala.AnyRef的子类，而不能是scala.AnyVal的子类)</p>

<p><3> <strong>Parameterized Types(参数化类型)</strong></p>

<p>基本格式: T[U1, U2, U3]</p>

<p>说明: 参数化的类型T[U1, U2, U3]包含类型指示器T，类型参数U1到Un，n&gt;=1。T必须是一个<b style="color:red">类型的构造器</b>并且接受n个类型参数。</p>

<p><strong>类型构造器</strong>的含义实际上就是必须是一个接受类型参数的类型，说的更直白一点就是必须要接受泛型参数。</p>

<p>实例:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-T1</span>, <span class="kt">+R</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AnyRef</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">TreeMap</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Comparable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="k">class</span> <span class="nc">F</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">X</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">S</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">String</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div>
<p><4> <strong>Tuple Types(元祖类型)</strong></p>

<p>基本格式: (T1 ... Tn), n&gt;=2</p>

<p>说明: 上面那种写法和这种写法是等价的Tuplen[T1...Tn]</p>

<p><5> <strong>Annotated Types(注解类型)</strong></p>

<p>基本格式: SimpleType {Annotation}</p>

<p>说明：带注解类型实际就是在类型后面添加必要的注解以告诉编译器你要的处理</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Foo</span>
<span class="k">class</span> <span class="nc">Bar</span> <span class="k">extends</span> <span class="nc">Foo</span>

<span class="k">import</span> <span class="nn">scala.reflect.runtime.</span><span class="o">{</span> <span class="n">universe</span> <span class="k">=&gt;</span> <span class="n">ju</span> <span class="o">}</span>

<span class="k">def</span> <span class="n">meth</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">ju.TypeTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
<span class="cm">/* 
我们知道像List这种带参数类型的类型，
在运行时类型会被擦除，
所以一般无法直接进行类型匹配。
另外在编译的时候，也会有警告。所以为了抑制编译器的警告，
给类型参数加上@unchecked，也就是上面所说的带注解的类型。
*/</span>

<span class="k">case</span> <span class="n">strList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span> <span class="kt">@</span> <span class="kt">unchecked</span><span class="o">]</span> 
    <span class="k">if</span> <span class="n">ju</span><span class="o">.</span><span class="n">typeTag</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">tpe</span> <span class="o">=:=</span> <span class="n">ju</span><span class="o">.</span><span class="n">typeOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"list of Strings"</span>
<span class="k">case</span> <span class="n">barList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Bar</span> <span class="kt">@</span> <span class="kt">unchecked</span><span class="o">]</span> 
    <span class="k">if</span> <span class="n">ju</span><span class="o">.</span><span class="n">typeTag</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">tpe</span> <span class="o">=:=</span> <span class="n">ju</span><span class="o">.</span><span class="n">typeOf</span><span class="o">[</span><span class="kt">Bar</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">"list of Bar"</span>
<span class="o">}</span>
</code></pre></div>
<p><6> <strong>Compound Types(复合类型)</strong></p>

<p>基本格式：T1 with ... with Tn { Refinement }</p>

<p>说明: 下面两段是按照Scala Reference原文翻译的，可能有点不那么优雅，我会尽量用实例来解释其中所提到的观点的。</p>

<p>(1) 上面定义了一个复合类型，它<b style="color:red">拥有类型T1..Tn以及Refinement中成员的对象</b>。
Refinement(我也不知道中文怎么翻译，╮(╯▽╰)╭)，实际就是一些的定义和类型声明，比如说定义一个方法什么的。</p>

<p>如果声明或定义覆盖了<b style="color:red">T1 with ... with Tn</b>中的某个声明或定义，那么适用于一般的覆盖规则。如果没有的话，那么这种声明或定义被称为<b style="color:red">结构化</b>的。</p>

<p>(2) 在结构化的声明或定义的 Refinement部分，所有值的类型只能引用在Refinement中的类型参数或者是定义的抽象类型。</p>

<p>(3) 如果没有Refinement的话，那么上面的定义就相当于<b style="color:red">T1 with ... with Tn { }</b>。反过来也可以没有前面的类型T1...Tn，也就是AnyRef { R }。</p>

<p>下面一一解释上面的知识点。</p>

<p>定义:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">type1</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">" type1 被初始化"</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">trait</span> <span class="nc">type2</span> <span class="o">{</span> 
    <span class="n">println</span><span class="o">(</span><span class="s">" type2 被初始化"</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">structual</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">SingleType</span> <span class="o">{</span> 
    <span class="n">self</span><span class="k">:</span> <span class="k">type</span><span class="err">1</span> <span class="kt">with</span> <span class="k">type</span><span class="err">2</span> <span class="o">{</span> <span class="kt">def</span> <span class="kt">structual</span><span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">}</span>
    <span class="o">=&gt;</span> 
<span class="o">}</span>
<span class="cm">/* 
  要求SingleType的实例必须是 
  type1 with type2 { def structual(s: String) } 这样的类型，
  具体到这段代码就是SingleType's instance必须继承type1, type2
  并且还需要定义def structual(s: String)这样一个函数  
*/</span>
<span class="o">}</span>

<span class="c1">// 定义获取类型的方法，使用到Scala反射(TODO: 以后会用专门的一篇博客来说明这个问题的)。
</span><span class="k">import</span> <span class="nn">scala.reflect.runtime.universe.</span><span class="o">{</span> <span class="nc">TypeTag</span><span class="o">,</span> <span class="n">typeTag</span> <span class="o">}</span>
<span class="k">def</span> <span class="n">getTypeTag</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">TypeTag</span><span class="o">](</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">typeTag</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">tpe</span>
</code></pre></div>
<p>调用:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 由于type2中定义了structual方法，所以singleType相当于定义了structual，编译通过
</span><span class="k">val</span> <span class="n">structuralSingleType</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SingleType</span> <span class="k">with</span> <span class="n">type1</span> <span class="k">with</span> <span class="n">type2</span>
<span class="n">getTypeTag</span><span class="o">(</span><span class="n">structuralSingleType</span><span class="o">)</span>

<span class="c1">// singleType类型
</span><span class="n">jacoffee</span><span class="o">.</span><span class="n">scalabasic</span><span class="o">.</span><span class="nc">SingleType</span>
    <span class="k">with</span> <span class="n">jacoffee</span><span class="o">.</span><span class="n">scalabasic</span><span class="o">.</span><span class="nc">Type1</span> 
    <span class="k">with</span> <span class="n">jacoffee</span><span class="o">.</span><span class="n">scalabasic</span><span class="o">.</span><span class="nc">Type2</span>
</code></pre></div>
<p><b style="color:red">(1)</b>， 上面那种singleType就被称之为结构化的。如果定义中覆盖了T1..Tn中的方法</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 注意定义的时候初始化的方向 SingleType -&gt; type1 -&gt; type2
// 下面这种方式的话，那么SingleType就是非结构化的。
</span><span class="k">val</span> <span class="n">unStructuralSingleType</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SingleType</span> <span class="k">with</span> <span class="n">type1</span> <span class="k">with</span> <span class="n">type2</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">structural</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<blockquote>
<p>A reference to a structurally defined member (method call or access to a value or variable) may generate binary code that is significantly slower than an equivalent code to a non-structural member</p>
</blockquote>

<p>引用结构化定义的成员(方法调用，访问变量)会导致生成的二进制码比非结构化的效率低(<b style="color:red">目前的水平还无法解释</b>)</p>

<p><b style="color:red">(2)</b>，如果修改SingleType的定义如下:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">SingleType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span><span class="k">:</span> <span class="k">type</span><span class="err">1</span> <span class="kt">with</span> <span class="k">type</span><span class="err">2</span> <span class="o">{</span> 
    <span class="kt">def</span> <span class="kt">structual</span><span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">:</span> <span class="kt">A</span> <span class="o">}</span> <span class="o">=&gt;</span>
<span class="o">}</span>
</code></pre></div>
<blockquote>
<p>Parameter type in structural refinement may not refer to an abstract type defined outside that refinement。
  在结构化的Refinement中不能引用它之外的类型参数。</p>
</blockquote>

<p><b style="color:red">(3)</b>，下面的定义也是可以的。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">SingleType</span> <span class="o">{</span> <span class="n">self</span><span class="k">:</span> <span class="kt">AnyRef</span> <span class="o">{</span> <span class="kt">def</span> <span class="kt">structual</span><span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">SingleType</span> <span class="o">{</span> <span class="n">self</span><span class="k">:</span> <span class="o">{</span> <span class="kt">def</span> <span class="kt">structual</span><span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">SingleType</span> <span class="o">{</span> <span class="n">self</span><span class="k">:</span> <span class="k">type</span><span class="err">1</span> <span class="kt">with</span> <span class="k">type</span><span class="err">2</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">SingleType</span> <span class="o">{</span> <span class="n">self</span><span class="k">:</span> <span class="k">type</span><span class="err">1</span> <span class="kt">with</span> <span class="k">type</span><span class="err">2</span> <span class="o">{}</span> <span class="o">}</span>
</code></pre></div>
<p>最后用一个实际的例子总结:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Bird</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Object</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fly</span><span class="o">(</span><span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="s">"鸟的飞行高度: "</span> <span class="o">+</span> <span class="n">height</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Plane</span><span class="o">(</span><span class="k">val</span> <span class="n">code</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Object</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fly</span><span class="o">(</span><span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="s">"代号:  "</span> <span class="o">+</span>
     <span class="n">code</span> <span class="o">+</span> <span class="s">"的飞机的飞行高度: "</span> <span class="o">+</span> <span class="n">height</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">HeightTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="cm">/*
    通过定义复合类型的参数r， takeOff的第二个参数
    可以接受任何定义了code属性和fly方法的对象
  */</span>
  <span class="k">def</span> <span class="n">takeOff</span><span class="o">(</span>
    <span class="n">location</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">r</span><span class="k">:</span> <span class="o">{</span> <span class="kt">val</span> <span class="kt">code:</span> <span class="kt">String</span><span class="o">;</span> <span class="kt">def</span> <span class="kt">fly</span><span class="o">(</span><span class="kt">height:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">" 起飞点 "</span> <span class="o">+</span> <span class="n">location</span><span class="o">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">fly</span><span class="o">(</span><span class="mi">300</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">bird</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Bird</span><span class="o">(</span><span class="s">"wudi"</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">code</span> <span class="k">=</span> <span class="s">"flappy bird"</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="n">plane</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Plane</span><span class="o">(</span><span class="s">"Boeing"</span><span class="o">)</span>
  <span class="n">takeOff</span><span class="o">(</span><span class="s">"terminal1"</span><span class="o">,</span> <span class="n">plane</span><span class="o">)</span>
  <span class="n">takeOff</span><span class="o">(</span><span class="s">"tree"</span><span class="o">,</span> <span class="n">bird</span><span class="o">)</span>
<span class="o">}</span>

</code></pre></div>
<p><7> <strong>Infix Types(中置语法)</strong></p>

<p>基本格式: T1 op T2</p>

<p>说明: 上面的表达式中中置操作符会在T1,T2上面调用，它等价于op[T1, T2]。
中置操作符(我们可以自定义，但是不能使用*，因为它已经用于后缀修饰符表示可以传递多个参数)。</p>

<p>所有的中置操作符都是有优先级的。除了<b style="color:red">:</b>是右连接，其余的都是左连接。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// Array.scala
</span><span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">//数组初始化的时候调用的是上面的方法
// T* 表示传递多个T类型的参数
</span><span class="k">val</span> <span class="n">newArr</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> 

<span class="c1">// 关于:, 最典型的当然是scala.collection.immutable.List
// 运算是从右往左的
</span><span class="k">val</span> <span class="n">newList</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="nc">Nil</span>
</code></pre></div>
<p>同样一个实例总结:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Converter</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">R</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="n">T</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">StringConverter</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Converter</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">InfixTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">type</span> <span class="o">==&gt;[</span><span class="kt">T</span>, <span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Converter</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">R</span><span class="o">]</span>

    <span class="k">val</span> <span class="n">infixType</span><span class="k">:</span> <span class="o">==&gt;[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> 
        <span class="k">new</span> <span class="o">==&gt;[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
         <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">toString</span>
        <span class="o">}</span>

  <span class="k">val</span> <span class="n">infixTypeComplex</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> 
      <span class="k">new</span> <span class="o">==&gt;[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">toString</span>
      <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><8> <strong>Function Types(函数类型)</strong></p>

<p>基本格式: FunctionArgs =&gt; Type</p>

<p>&amp; (T1, ..., Tn) =&gt; U 表示的是一个函数接受n个参数，并且返回类型U</p>

<p>&amp; 函数类型都是右连接的，S =&gt; T =&gt; U相当于S =&gt; (T =&gt; U)</p>

<p>&amp; 函数类型等价于定义了<b style="color:red">apply方法并且接受相应类型参数的类</b>。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">scala</span>

<span class="c1">// 另外Scala函数的参数是逆变的，返回值是协变的
</span><span class="k">trait</span> <span class="nc">Functionn</span><span class="o">[</span><span class="kt">-T1</span>,<span class="kt">...</span>, <span class="kt">-Tn</span>, <span class="kt">+R</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x1</span><span class="k">:</span> <span class="kt">T1</span><span class="o">,...,</span><span class="n">xn</span><span class="k">:</span> <span class="kt">Tn</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">"&lt;function&gt;"</span> 
<span class="o">}</span>
</code></pre></div>
<h3>2015-08-02 更新</h3>

<p><9> <strong>Existential Types</strong></p>

<p>对于什么是Existential Types，在《Scala In Depth》这本书中有段解释还是比较易懂的。</p>

<blockquote>
<p>Existential types are a means of constructing types where portions of the type signature are existential, where existential means that although some real type meets that portion of a type signature, we don’t care about the specific type. Existential types were introduced into Scala as a means to interoperate with Java’s generic types, such as Iterator&lt;?&gt; or Iterator&lt;? extends Component&gt;</p>
</blockquote>

<p>Existential Types用于构造类型的时候，有一部分已经是确定的类型(library中的各种yi&#39;zhi)已知的数据类型， 自己定义的类型class, trait)。</p>

<p>基本格式: T forSome { ‘type’ TypeDcl | ‘val’ ValDcl } </p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// 在实际使用中，我们一般是 _ 来表示
</span><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">=</span> <span class="n">x</span> 
<span class="c1">// 完整形式
</span><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="o">}])</span> <span class="k">=</span> <span class="n">x</span>
</code></pre></div><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="cm">/* 
下例中的List并不是scala.collection.immutable, 而是一个高阶类型。AA || List 
都不是real type, 因为编译器在编译的时候对它们的了解仅限于它们是一个高阶类型参数。
但是在方法参数的地方，AA已经是一个定义的高阶类型了，满足real type所以是一个Existential Type。
*/</span>
<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">=</span> <span class="n">x</span>
<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">AA</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">x</span><span class="k">:</span> <span class="kt">AA</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">=</span> <span class="n">x</span>
<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">AA</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">x</span><span class="k">:</span> <span class="kt">AA</span><span class="o">[</span><span class="kt">t</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">t</span><span class="o">}])</span> <span class="k">=</span> <span class="n">x</span>

<span class="c1">// 因为方法类型参数的地方， AA刚被定义所以并不满足real type的定义。有点类似于变量先定义后使用的味道。因此下面的用法是不对的。
</span><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">AA</span><span class="o">[</span><span class="kt">t</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">t</span><span class="o">}]](</span><span class="n">x</span><span class="k">:</span> <span class="kt">AA</span><span class="o">[</span><span class="kt">t</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">t</span><span class="o">}])</span> <span class="k">=</span> <span class="n">x</span>
</code></pre></div>
<p>从完整版的定义中，T实际上是有可以Upper Bound 和 Lower Bound的，默认情况下
 type T =&gt; type T &gt;: scala.Nothing &lt;: scala.AnyRef</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// Scala compiler 不在意传入什么类型，只要该类型是Int或者是Int的超类即可
</span><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="k">&gt;:</span> <span class="kt">Int</span><span class="o">}])</span> <span class="k">=</span> <span class="n">x</span>

<span class="n">foo</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"hello"</span><span class="o">))</span> <span class="c1">// 因为String与Int的共同父类是Any, 所以上例的T的类型是Any
</span></code></pre></div>
<p>另外forSome block中定义的类型在T中都是可以被引用的。</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Outer</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">AbsT</span>

    <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">proc</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> 
<span class="o">}</span>

<span class="k">type</span> <span class="kt">Ref</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="nc">AbsT</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Outer</span> <span class="o">}</span>
</code></pre></div>
<h1>参考</h1>

<p><1> Scala Reference 3.2</p>

<p><2> <a href="http://jim-mcbeath.blogspot.com/2008/11/scala-type-infix-operators.html">scala-type-infix-operators</a></p>

<p><3> <a href="https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/typeoperators.scala">type-operators.scala</a></p>

<p><4> <a href="http://stackoverflow.com/questions/31937965/scala-method-type-parameter-can-not-accept-existential-type-in-forsome-form/31978204#31978204">scala-method-type-parameter-can-not-accept-existential-type-in-forsome-form</a></p>

</article>


<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: 
<a href="/scala/value-types/" rel="nofollow">Allen</a></p>

<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/scala/type-class/" rel="prev">&laquo;&nbsp;Scala基础之类型类(type class pattern)</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/scala/for-expression/" rel="next">Scala基础之For表达式&nbsp;&raquo;</a></div>
    
</section>


<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="0e78a72174e18bd5eb0b22b1dfc6f75a" data-title="Scala基础之值类型(value types)" data-url="/scala/value-types/"></div>
<!-- 多说评论框 end -->



    <footer class="lotus-footer">
        <p>©2016 allen with website template from <a href="https://github.com/pizn/iLotus" target="_blank">iLotus</a> </p>
    </footer>
    <script src="/static/js/jquery.js" type="text/javascript"></script>
    <script src="/static/js/jquery.scrollTo.js" type="text/javascript"></script>
    <script src="/static/js/iLotus.js" type="text/javascript"></script>
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "roadtopro"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</body>

</html>