---
layout: post
category: scala
date: 2015-02-04 22:11:38 UTC
title: Scala基础之try...catch...finally
tags: [异常处理, 字节]
permalink: /scala/try-catch/
md5: 9fc1d12984edc4fbd228195de9084ada
---


# 问题
今天，一同事在写一个异常捕获的时候，突然抛出以下代码，让我们研究返回值。

```scala
def getResult: Int = try {
    println("try执行了吗？"）
    return 1
} finally {
    println("finally执行了吗？"）
    return 3
}
```
首先上面那种写法就很奇怪，因为不管是在Scala还是Java中finally一般都是没有返回值的，如果显示声明了return, 那么返回值应该是多少了。答案是此时返回值应该是<b style="color:red">finally中return的值</b>。
如果try中有异常而finally中没有异常且显示的声明了return，此时整个流程怎么走？
如果finally有异常，整个流程又怎么走？
本文会对Scala中detry...catch...finally的整个语法进行梳理，如有不对的地方还请大家指出。
  
# 解决
首先为什么上面的表达式返回的是3，都说源码面前，了无秘密。通过[Java Decompiler](http://jd.benow.ca/)将上面的Scala代码对应的class文件反解，就可以看到如下代码:

```java
public int getResult() {
    try { Predef..MODULE$.println("try 执行了吗？ ");

      return 3;
    }
    finally
    {
      Predef..MODULE$.println(" finally 执行了吗");
    }return 3;
  }
```
显然，finally中的代码已经改变原来的方法的执行流程，可以简单的理解为在Scala中
对于try { b } catch e1 finally e2
<b style="color:red">b的类型是try表达式的期望类型, e1实际上是一个偏函数: scala.PartialFunction[scala.Throwable, pt], pt <: b, 而e2的类型则是Unit</b>。
所以此时的控制流程又回到了try表达式中，因为此时<b style="color:red">只有try{}才可以返回满足方法签名类型的返回值</b>,也就是Int。
同时会将finally中的'返回值'作为最终的值返回。

下面针对不同情况下，try...catch...finally的处理进行解释:

<1> 计算b的过程中没有异常
    
如果在计算表达式e的过程中又抛出异常，那么整个表达式会中止，并且抛出异常(e表达式中包含的异常)

如果在计算表达式的e的过程中没有抛出异常，那么b就是整个表达式的返回值

<2> 计算b的过程中有异常(e中的表达式仍然会被计算)

如果e的计算过程也抛出异常，那么表达式会中止并且e过程中的异常被抛出

如果e的计算过程中没有抛出异常，那么原来b中的异常会再e计算完成之后再次抛出

# 结语
我们最开始学习Java时候，各种教材都会讲到在定义Java变量名我们尽量不要采用生僻的命名，这条规则同样适用于这里。我们尽量不要使用各种语法比较妖孽的地方，就比如说finally本来就不该出现return，它通常会用于处理异常抛出之后的收尾工作，比如说关闭流等。